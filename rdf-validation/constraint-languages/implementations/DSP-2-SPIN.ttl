@prefix fn:           <http://www.w3.org/2005/xpath-functions#> .
@prefix sparql:       <http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#> .
@prefix xsd:          <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:          <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:         <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:          <http://www.w3.org/2002/07/owl#> .
@prefix sp:           <http://spinrdf.org/sp#> .
@prefix spin:         <http://spinrdf.org/spin#> .
@prefix smf:          <http://topbraid.org/sparqlmotionfunctions#> .
@prefix spif:         <http://spinrdf.org/spif#> . 
@prefix spl:          <http://spinrdf.org/spl#> . 
@prefix spinx:        <http://spinrdf.org/spinx#> . 
@prefix owl2: 		  <http://constraints.org/owl2#> .
@prefix functions:    <http://www.example.org/functions#> .
@prefix templates:    <http://www.example.org/templates#> .
@prefix sparql:       <http://www.w3.org/TR/sparql11-query/#> .
@prefix a:            <http://www.example.org/OWL2InstanceData#> .
@prefix dcam:         <http://purl.org/dc/dcam#> .
@prefix dsp:          <http://dublincore.org/dc-dsp#> .
@prefix dspFunctions: <http://dublincore.org/dc-dsp/functions#> .
@prefix dsp2spin:     <http://dublincore.org/dc-dsp/spin-mapping#> .

<constraints/owl> 
	a owl:Ontology ;
	rdfs:comment "" ;
	owl:imports <http://spinrdf.org/spl> ;
	owl:imports <http://www.w3.org/2005/xpath-functions> ;
	owl:versionInfo "0.0.1" .

	
# ---------------
# Description Templates [done]


owl:Thing
	spin:constraint 
#[done]	#   Identifier
		
#[done]	#   Standalone
		[   a dsp2spin:DescriptionTemplates_Standalone_No ] ,
		[   a dsp2spin:DescriptionTemplates_Standalone_1 ] ,
		
#[done]	#   Minimum Occurrence Constraint
		[   a dsp2spin:DescriptionTemplates_MinimumOccurrenceConstraint_1 ] ,
		
#[done]	#   Maximum Occurrence Constraint
		[   a dsp2spin:DescriptionTemplates_MaximumOccurrenceConstraint ] .
		
#[done]	#   Resource Class Membership Constraint
		
dsp:DescriptionTemplate
	spin:constraint 
#[done] #   Standalone
		[   a dsp2spin:DescriptionTemplates_Standalone_AllowedValues ] ,
#[done]	#   Minimum Occurrence Constraint
		[   a dsp2spin:DescriptionTemplates_MinimumOccurrenceConstraint_2 ] ,
		[   a dsp2spin:DescriptionTemplates_MinimumOccurrenceConstraint_AllowedValues ] ,
#[done]	#   Maximum Occurrence Constraint
		[   a dsp2spin:DescriptionTemplates_MaximumOccurrenceConstraint_AllowedValues ] .

# -----

# ---------------
# Statement Templates [done]


owl:Thing
	spin:constraint 
#[done]	#   Minimum occurrence constraint
		[   a dsp2spin:StatementTemplates_MinimumOccurrenceConstraint_1 ] ,
#[done]	#   Maximum occurrence constraint
		[   a dsp2spin:StatementTemplates_MaximumOccurrenceConstraint ] .
#[done]	#   Type Constraint

dsp:DescriptionTemplate
	spin:constraint 
#[done]	#   Minimum Occurrence Constraint
		[   a dsp2spin:StatementTemplates_MinimumOccurrenceConstraint_2 ] ,
		[   a dsp2spin:StatementTemplates_MinimumOccurrenceConstraint_AllowedValues ] ,
#[done]	#   Maximum Occurrence Constraint
		[   a dsp2spin:StatementTemplates_MaximumOccurrenceConstraint_AllowedValues ] .
		
# -----

# ---------------
# Property Constraints [done]


owl:Thing
	spin:constraint 
#[done]	#   Property List Constraint
		[   a dsp2spin:PropertyConstraints_PropertyListConstraint ] ,
#[done]	#   Sub-Property Constraint
		[   a dsp2spin:PropertyConstraints_Sub-PropertyConstraint ] .
		
dsp:DescriptionTemplate
	spin:constraint 
#[done]	#   Property List Constraint
		[   a dsp2spin:PropertyConstraints_PropertyListConstraint_2 ] .
		
# -----

# ---------------
# Literal Value Constraints [done]


owl:Thing
	spin:constraint 
#[done] #   Literal List Constraint
		[   a dsp2spin:LiteralValueConstraints_LiteralListConstraint ] ,
		[   a dsp2spin:LiteralValueConstraints_LiteralListConstraint_LiteralLanguageConstraint ] ,
		[   a dsp2spin:LiteralValueConstraints_LiteralListConstraint_LiteralLanguageListConstraint ] ,
		[   a dsp2spin:LiteralValueConstraints_LiteralListConstraint_SyntaxEncodingSchemeConstraint ] ,
		[   a dsp2spin:LiteralValueConstraints_LiteralListConstraint_SyntaxEncodingSchemeListConstraint ] ,
#[done]	#   Literal Language Constraint
		[   a dsp2spin:LiteralValueConstraints_LiteralLanguageConstraint_Mandatory ] ,
		[   a dsp2spin:LiteralValueConstraints_LiteralLanguageConstraint_Mandatory_SyntaxEncodingSchemes ] ,
		[   a dsp2spin:LiteralValueConstraints_LiteralLanguageConstraint_Disallowed ] ,
#[done]	#   Literal Language List Constraint
		[   a dsp2spin:LiteralValueConstraints_LiteralLanguageListConstraint ] ,
#		[   a dsp2spin:LiteralValueConstraints_LiteralLanguageListConstraint_Testing ] ,
#[done]	#   Syntax Encoding Scheme Constraint
#		[   a dsp2spin:LiteralValueConstraints_SyntaxEncodingSchemeConstraint_Mandatory ] ,
		[   a dsp2spin:LiteralValueConstraints_SyntaxEncodingSchemeConstraint_Disallowed ] ,
		[   a dsp2spin:LiteralValueConstraints_SyntaxEncodingSchemeConstraint_LanguageTags ] ,
#[done]	#   Syntax Encoding Scheme List Constraint
		[   a dsp2spin:LiteralValueConstraints_SyntaxEncodingSchemeListConstraint ] .
		
# -----

# ---------------
# Non-Literal Value Constraints


owl:Thing
	spin:constraint 
#[done] #   Description Template Reference
		[   a dsp2spin:NonLiteralValueConstraints_DescriptionTemplateReference ] ,
#[done]	#   Class Membership Constraint
		[   a dsp2spin:NonLiteralValueConstraints_ClassMembershipConstraint ] ,
#[done]	#   Value URI Occurrence Constraint
		[   a dsp2spin:NonLiteralValueConstraints_ValueURIOccurrenceConstraint_Mandatory ] ,
		[   a dsp2spin:NonLiteralValueConstraints_ValueURIOccurrenceConstraint_Disallowed ] ,
#[done]	#   Value URI List Constraint
		[   a dsp2spin:Non-LiteralValueConstraints_ValueURIListConstraint ] ,
#[done]	#   Vocabulary Encoding Scheme Occurrence Constraint
		[   a dsp2spin:NonLiteralValueConstraints_VocabularyEncodingSchemeOccurrenceConstraint_Mandatory ] ,
		[   a dsp2spin:NonLiteralValueConstraints_VocabularyEncodingSchemeOccurrenceConstraint_Disallowed ] ,
#[done]	#   Vocabulary Encoding Scheme List Constraint
		[   a dsp2spin:Non-LiteralValueConstraints_VocabularyEncodingSchemeListConstraint ] ,
#[done]	#  	Minimum Occurrence Constraint
		[   a dsp2spin:Non-LiteralValueConstraints_MinimumOccurrenceConstraint ] ,
#[done]	#  	Maximum Occurrence Constraint
		[   a dsp2spin:Non-LiteralValueConstraints_MaximumOccurrenceConstraint ] ,
#[done]	#   Literal List Constraint
		[   a dsp2spin:NonLiteralValueConstraints_LiteralListConstraint ] ,
		[   a dsp2spin:NonLiteralValueConstraints_LiteralListConstraint_LiteralLanguageConstraint ] ,
		[   a dsp2spin:NonLiteralValueConstraints_LiteralListConstraint_LiteralLanguageListConstraint ] ,
		[   a dsp2spin:NonLiteralValueConstraints_LiteralListConstraint_SyntaxEncodingSchemeConstraint ] ,
		[   a dsp2spin:NonLiteralValueConstraints_LiteralListConstraint_SyntaxEncodingSchemeListConstraint ] ,
#[done]	#   Literal Language Constraint
		[   a dsp2spin:NonLiteralValueConstraints_LiteralLanguageConstraint_Mandatory ] ,
		[   a dsp2spin:NonLiteralValueConstraints_LiteralLanguageConstraint_Mandatory_SyntaxEncodingSchemes ] ,
		[   a dsp2spin:NonLiteralValueConstraints_LiteralLanguageConstraint_Disallowed ] ,
#[done]	#   Literal Language List Constraint 
		[   a dsp2spin:NonLiteralValueConstraints_LiteralLanguageListConstraint ] ,		
#[done]	#   Syntax Encoding Scheme Constraint
#		[   a dsp2spin:NonLiteralValueConstraints_SyntaxEncodingSchemeConstraint_Mandatory ] ,
		[   a dsp2spin:NonLiteralValueConstraints_SyntaxEncodingSchemeConstraint_Disallowed ] ,
		[   a dsp2spin:NonLiteralValueConstraints_SyntaxEncodingSchemeConstraint_LanguageTags ] ,
		
		#   Syntax Encoding Scheme List Constraint
		[   a dsp2spin:NonLiteralValueConstraints_SyntaxEncodingSchemeListConstraint ] .
		
dsp:DescriptionTemplate
	spin:constraint 
#[done]	#  	Minimum Occurrence Constraint
		[   a dsp2spin:Non-LiteralValueConstraints_MinimumOccurrenceConstraint_2 ] ,
		[   a dsp2spin:Non-LiteralValueConstraints_MinimumOccurrenceConstraint_AllowedValues ] ,
#[done]	#  	Maximum Occurrence Constraint
		[   a dsp2spin:Non-LiteralValueConstraints_MaximumOccurrenceConstraint_AllowedValues ] ,
#[done]	#   Vocabulary Encoding Scheme Occurrence Constraint
		[   a dsp2spin:NonLiteralValueConstraints_VocabularyEncodingSchemeOccurrenceConstraint_AllowedValues ] .
		
# -----

	

	
	
		

# ---------------
# Description Templates - Identifier [done]


# Summary: A string that can be used in a Value Constraint to reference a description template that applies to the value resource. 
# Allowed values: A valid XML ID string. 
# Default: N/A 

# --> RDF: resource URI
# --> no constraint in RDF  

# -----

# ---------------
# Description Templates - Standalone [done]


# Summary: Whether descriptions matching this template are allowed to occur standalone, i.e. without being the value of a property. 
# Allowed values: "yes", "no", "both" 
# Default: "both" --> no constraint needed 
# Conditions:
# - If standalone is "yes", a matching description may not be a description of value occurring elsewhere in the DSP. --> no constraint needed 
# - If standalone is "no", a matching description *must* be a description of value occurring elsewhere in the DSP. 
# - If standalone is "both", both are allowed. --> no constraint needed 
# - If this description template is referred to in a Value Constraint, standalone cannot be "yes". 


# "false"^^xsd:boolean
# -----
dsp2spin:DescriptionTemplates_Standalone_No
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
			
#           ?descriptionTemplate dsp:standalone "false"^^xsd:boolean .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:standalone ;
				sp:object "false"^^xsd:boolean ]
			
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]

#           FILTER NOT EXISTS { ?s ?p ?this . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "s" ] ;
                            sp:predicate [ sp:varName "p" ] ;
                            sp:object [ sp:varName "this" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "description matching the template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " ) is not allowed to occur standalone, i.e. without being the value of a property" ;
					sp:arg4 " )" ] ] ) ].
					
# Allowed values: "true"^^xsd:boolean, "false"^^xsd:boolean, "both"^^xsd:string
# -----		
dsp2spin:DescriptionTemplates_Standalone_AllowedValues
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
			
#           ?this dsp:standalone ?standalone .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:standalone ;
				sp:object [ sp:varName "standalone" ] ]
	
#           FILTER ( ?standalone != "true"^^xsd:boolean && ?standalone != "false"^^xsd:boolean && ?standalone != "both"^^xsd:string ) .
#           -----
			[   a sp:Filter ;
                sp:expression [
					a sp:and ;
                    sp:arg1  
						[   a sp:and ;
							sp:arg1  
								[   a sp:ne ;
									sp:arg1 [ sp:varName "standalone"^^xsd:string ] ;
									sp:arg2 "true"^^xsd:boolean 
								] ;
							sp:arg2  
								[   a sp:ne ;
									sp:arg1 [ sp:varName "standalone"^^xsd:string ] ;
									sp:arg2 "false"^^xsd:boolean ] ] ;
                    sp:arg2  
						[   a sp:ne ;
                            sp:arg1 [ sp:varName "standalone"^^xsd:string ] ;
                            sp:arg2 "both"^^xsd:string ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The standalone value ( " ;
					sp:arg2 [ sp:varName "standalone" ] ;
					sp:arg3 " ) is not one of the allowed standalone values ( 'true'^^xsd:boolean, 'false'^^xsd:boolean, 'both'^^xsd:string )" ] ] ) ].	

# If this description template is referred to in a Value Constraint, standalone cannot be "true"^^xsd:boolean. 
# -----
dsp2spin:DescriptionTemplates_Standalone_1
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
			
#           ?descriptionTemplate dsp:standalone "true"^^xsd:boolean .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:standalone ;
				sp:object "true"^^xsd:boolean ]
			
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]

#           FILTER EXISTS { 
#		        ?dt rdf:type dsp:DescriptionTemplate .   
#               ?dt dsp:statementTemplate ?st .
#               ?st dsp:nonLiteralConstraint ?nlc .
#               ?nlc dsp:descriptionTemplate ?descriptionTemplate .           
#           }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "dt" ] ;
                            sp:predicate rdf:type ;
                            sp:object dsp:DescriptionTemplate ] 
						[   sp:subject [ sp:varName "dt" ] ;
                            sp:predicate dsp:statementTemplate ;
                            sp:object [ sp:varName "st" ] ] 
						[   sp:subject [ sp:varName "st" ] ;
                            sp:predicate dsp:nonLiteralConstraint ;
                            sp:object [ sp:varName "nlc" ] ] 
						[   sp:subject [ sp:varName "nlc" ] ;
                            sp:predicate dsp:descriptionTemplate ;
                            sp:object [ sp:varName "descriptionTemplate" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " ) is referred to in a Value Constraint, standalone cannot be 'true'^^xsd:boolean." ] ] ) ].
					
# -----

# ---------------
# Description Templates- Minimum Occurrence Constraint [done]


# Summary: The minimum number of times this kind of description must appear in the Description Set. 
# Allowed values: non-negative integer
# Default: 0 --> no constraint needed
# Conditions: must be equal or less than the Maximum occurrence 

# The minimum number of times this kind of description must appear in the Description Set. 
# -----
dsp2spin:DescriptionTemplates_MinimumOccurrenceConstraint_1
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:minOccur ?minOccurDescription .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurDescription" ] ]
				
#	    	cardinalityDescription < minOccurDescription
#	    	-----
#	    	BIND ( ( dspFunctions:cardinalityDescription ( resourceClass ) ) AS ?cardinalityDescription ) . }
#			FILTER ( cardinalityDescription < ?minOccurDescription ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinalityDescription" ] ;
				sp:expression [
					a dspFunctions:cardinalityDescription ;
					sp:arg1 [ sp:varName "resourceClass" ] ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "cardinalityDescription" ] ;
					sp:arg2 [ sp:varName "minOccurDescription" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "cardinality description ( " ;
					sp:arg2 [ sp:varName "cardinalityDescription" ] ;
					sp:arg3 ") < minOccur description ( " ;
					sp:arg4 [ sp:varName "minOccurDescription" ] ;
					sp:arg5 " )" ] ] ) ].
					
# dsp:minOccur <= dsp:maxOccur
# -----
dsp2spin:DescriptionTemplates_MinimumOccurrenceConstraint_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {		
#           ?this dsp:minOccur ?minOccurDescription .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurDescription" ] ]
				
#           ?this dsp:maxOccur ?maxOccurDescription .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurDescription" ] ]
				
#			FILTER ( ?minOccurDescription > ?maxOccurDescription ) .
#           -----	   
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "minOccurDescription" ] ;
					sp:arg2 [ sp:varName "maxOccurDescription" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "minOccur description ( " ;
					sp:arg2 [ sp:varName "minOccurDescription" ] ;
					sp:arg3 " ) > maxOccur description ( " ;
					sp:arg4 [ sp:varName "maxOccurDescription" ] ;
					sp:arg5 " )" ] ] ) ].
					
# Allowed values: non-negative integer
# -----
dsp2spin:DescriptionTemplates_MinimumOccurrenceConstraint_AllowedValues
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {		
#           ?this dsp:minOccur ?minOccurDescription .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurDescription" ] ]
				
#           BIND( ( IF( sp:isNumeric ( ?minOccurDescription ), "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isNumeric ) .
#           FILTER ( ?isNumeric = "false"^^xsd:boolean ) . 
#           -----	
			[   a sp:Bind ;
				sp:expression [
					a sp:if ;
					sp:arg1 [ 
						a sp:isNumeric ;
						sp:arg1 [ sp:varName "minOccurDescription"^^xsd:string ] ] ;
					sp:arg2 "true"^^xsd:boolean ;
					sp:arg3 "false"^^xsd:boolean ] ;
				sp:variable [ sp:varName "isNumeric"^^xsd:boolean ] ] 
			[   a sp:Filter ;
				sp:expression [ 
					a sp:eq ;
					sp:arg1 [ sp:varName "isNumeric"^^xsd:boolean ] ;
					sp:arg2 "false"^^xsd:boolean ] ] 

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The minOccur description ( " ;
					sp:arg2 [ sp:varName "minOccurDescription" ] ;
					sp:arg3 " ) is not a non-negative integer as specified by the description template ( " ;
					sp:arg4 [ sp:varName "this" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Description Templates - Maximum occurrence constraint [done]


# Summary: The maximum number of times this kind of description is allowed to appear in the Description Set. 
# Allowed values: non-negative integer or "infinity" 
# Default: "infinity" --> no constraint needed
# Conditions: must be equal or greater than the Minimum occurrence 

# The maximum number of times this kind of description is allowed to appear in the Description Set. 
# -----
dsp2spin:DescriptionTemplates_MaximumOccurrenceConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:minOccur ?maxOccurDescription .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurDescription" ] ]
				
#	    	cardinalityDescription > maxOccurDescription
#	    	-----
#	    	BIND ( ( dspFunctions:cardinalityDescription ( resourceClass ) ) AS ?cardinalityDescription ) . }
#			FILTER ( cardinalityDescription > ?maxOccurDescription ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinalityDescription" ] ;
				sp:expression [
					a dspFunctions:cardinalityDescription ;
					sp:arg1 [ sp:varName "resourceClass" ] ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "cardinalityDescription" ] ;
					sp:arg2 [ sp:varName "maxOccurDescription" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "cardinality description ( " ;
					sp:arg2 [ sp:varName "cardinalityDescription" ] ;
					sp:arg3 ") < maxOccur description ( " ;
					sp:arg4 [ sp:varName "maxOccurDescription" ] ;
					sp:arg5 " )" ] ] ) ].
					
# Allowed values: non-negative integer or "infinity" 
# -----
dsp2spin:DescriptionTemplates_MaximumOccurrenceConstraint_AllowedValues
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:minOccur ?maxOccurDescription .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurDescription" ] ]
				
#           BIND( ( IF( sp:isNumeric ( ?maxOccurDescription ), "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isNumeric ) .
#           -----	
			[   a sp:Bind ;
				sp:expression [
					a sp:if ;
					sp:arg1 [ 
						a sp:isNumeric ;
						sp:arg1 [ sp:varName "maxOccurDescription"^^xsd:string ] ] ;
					sp:arg2 "true"^^xsd:boolean ;
					sp:arg3 "false"^^xsd:boolean ] ;
				sp:variable [ sp:varName "isNumeric"^^xsd:boolean ] ] 
	
#           FILTER ( ?isNumeric = "false"^^xsd:boolean && ?maxOccurDescription != "infinity"^^xsd:string ) .
#           -----
			[   a sp:Filter ;
                sp:expression [
					a sp:and ;
                    sp:arg1  
						[   a sp:eq ;
                            sp:arg1 [ sp:varName "isNumeric"^^xsd:string ] ;
                            sp:arg2 "false"^^xsd:boolean ] ;
                    sp:arg2  
						[   a sp:ne ;
                            sp:arg1 [ sp:varName "maxOccurDescription"^^xsd:string ] ;
                            sp:arg2 "infinity"^^xsd:string ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The maxOccur description ( " ;
					sp:arg2 [ sp:varName "maxOccurDescription" ] ;
					sp:arg3 " ) is not a non-negative integer or 'infinity' as specified by the description template ( " ;
					sp:arg4 [ sp:varName "this" ] ;
					sp:arg5 " )" ] ] ) ].	

# -----

# ---------------
# Description Templates - Resource Class Membership Constraint [done]


# Summary: Classes that the resource may be an instance of 
# Allowed values: a list of class URIs 
# Default: no constraint 
# Conditions: if given, the resource must be an instance of one of the given classes. 

# --> no constraint needed

# -----

# ---------------
# Statement Templates - Minimum occurrence constraint [done]


# Summary: The minimum number of times this kind of statement must appear in the enclosing Description. 
# Allowed values non-negative integer
# Default: 0 --> no constraint needed
# Conditions: must be equal or less than the Maximum occurrence 

# The minimum number of times this kind of statement must appear in the enclosing Description. 
# -----
dsp2spin:StatementTemplates_MinimumOccurrenceConstraint_1
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:minOccur ?minOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurStatement" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#	    	cardinalityStatement < minOccurStatement
#	    	-----
#	    	BIND ( ( spl:objectCount ( ?this, ?property ) ) AS ?cardinalityStatement ) . }
#			FILTER ( cardinalityStatement < ?minOccurStatement ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinalityStatement" ] ;
				sp:expression [
					a spl:objectCount ;
					sp:arg1 [ sp:varName "this" ] ;
					sp:arg2 [ sp:varName "property" ] ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "cardinalityStatement" ] ;
					sp:arg2 [ sp:varName "minOccurStatement" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "cardinality statement ( " ;
					sp:arg2 [ sp:varName "cardinalityStatement" ] ;
					sp:arg3 " ) < minOccur statement ( " ;
					sp:arg4 [ sp:varName "minOccurStatement" ] ;
					sp:arg5 " )" ] ] ) ].						

# dsp:minOccur <= dsp:maxOccur
# -----
dsp2spin:StatementTemplates_MinimumOccurrenceConstraint_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:minOccur ?minOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurStatement" ] ]
				
#           ?statementTemplate dsp:maxOccur ?maxOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurStatement" ] ]
				
#			FILTER ( ?minOccurStatement > ?maxOccurStatement ) .
#           -----	    
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "minOccurStatement" ] ;
					sp:arg2 [ sp:varName "maxOccurStatement" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "minOccur statement ( " ;
					sp:arg2 [ sp:varName "minOccurStatement" ] ;
					sp:arg3 " ) > maxOccur statement ( " ;
					sp:arg4 [ sp:varName "maxOccurStatement" ] ;
					sp:arg5 " )" ] ] ) ].
					
# Allowed values non-negative integer
# -----
dsp2spin:StatementTemplates_MinimumOccurrenceConstraint_AllowedValues
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:minOccur ?minOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurStatement" ] ]
				
#           BIND( ( IF( sp:isNumeric ( ?minOccurStatement ), "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isNumeric ) .
#           FILTER ( ?isNumeric = "false"^^xsd:boolean ) . 
#           -----	
			[   a sp:Bind ;
				sp:expression [
					a sp:if ;
					sp:arg1 [ 
						a sp:isNumeric ;
						sp:arg1 [ sp:varName "minOccurStatement"^^xsd:string ] ] ;
					sp:arg2 "true"^^xsd:boolean ;
					sp:arg3 "false"^^xsd:boolean ] ;
				sp:variable [ sp:varName "isNumeric"^^xsd:boolean ] ] 
			[   a sp:Filter ;
				sp:expression [ 
					a sp:eq ;
					sp:arg1 [ sp:varName "isNumeric"^^xsd:boolean ] ;
					sp:arg2 "false"^^xsd:boolean ] ] 

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The minOccur statement ( " ;
					sp:arg2 [ sp:varName "minOccurStatement" ] ;
					sp:arg3 " ) is not a non-negative integer as specified by the description template ( " ;
					sp:arg4 [ sp:varName "this" ] ;
					sp:arg5 " )" ] ] ) ].			
					
# -----

# ---------------
# Statement Templates - Maximum occurrence constraint [done]


# Summary: The maximum number of times this kind of statement is allowed to appear in the enclosing Description. 
# Allowed values: non-negative integer or "infinity" 
# Default: "infinity" --> no constraint needed
# Conditions: must be equal or greater than the Minimum occurrence  

# The maximum number of times this kind of statement is allowed to appear in the enclosing Description. 
# -----
dsp2spin:StatementTemplates_MaximumOccurrenceConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:maxOccur ?maxOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurStatement" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#	    	cardinalityStatement > maxOccurStatement
#	    	-----
#	    	BIND ( ( spl:objectCount ( ?this, ?property ) ) AS ?cardinalityStatement ) . }
#			FILTER ( cardinalityStatement > ?maxOccurStatement ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinalityStatement" ] ;
				sp:expression [
					a spl:objectCount ;
					sp:arg1 [ sp:varName "this" ] ;
					sp:arg2 [ sp:varName "property" ] ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "cardinalityStatement" ] ;
					sp:arg2 [ sp:varName "maxOccurStatement" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "cardinality statement ( " ;
					sp:arg2 [ sp:varName "cardinalityStatement" ] ;
					sp:arg3 " ) < maxOccur statement ( " ;
					sp:arg4 [ sp:varName "maxOccurStatement" ] ;
					sp:arg5 " )" ] ] ) ].
					
# Allowed values non-negative integer
# -----
dsp2spin:StatementTemplates_MaximumOccurrenceConstraint_AllowedValues
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:maxOccur ?maxOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurStatement" ] ]
				
#           BIND( ( IF( sp:isNumeric ( ?maxOccurStatement ), "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isNumeric ) .
#           -----	
			[   a sp:Bind ;
				sp:expression [
					a sp:if ;
					sp:arg1 [ 
						a sp:isNumeric ;
						sp:arg1 [ sp:varName "maxOccurStatement"^^xsd:string ] ] ;
					sp:arg2 "true"^^xsd:boolean ;
					sp:arg3 "false"^^xsd:boolean ] ;
				sp:variable [ sp:varName "isNumeric"^^xsd:boolean ] ] 
	
#           FILTER ( ?isNumeric = "false"^^xsd:boolean && ?maxOccurStatement != "infinity"^^xsd:string ) .
#           -----
			[   a sp:Filter ;
                sp:expression [
					a sp:and ;
                    sp:arg1  
						[   a sp:eq ;
                            sp:arg1 [ sp:varName "isNumeric"^^xsd:string ] ;
                            sp:arg2 "false"^^xsd:boolean ] ;
                    sp:arg2  
						[   a sp:ne ;
                            sp:arg1 [ sp:varName "maxOccurStatement"^^xsd:string ] ;
                            sp:arg2 "infinity"^^xsd:string ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The maxOccur statement ( " ;
					sp:arg2 [ sp:varName "maxOccurStatement" ] ;
					sp:arg3 " ) is not a non-negative integer or 'infinity' as specified by the description template ( " ;
					sp:arg4 [ sp:varName "this" ] ;
					sp:arg5 " )" ] ] ) ].		
					
# -----

# ---------------
# Statement Templates - Type Constraint [done]


# Summary: The type of value surrogate (literal/non-literal) that is allowed in this Statement. 
# Allowed values: "literal" / "nonliteral" 
# Default: both allowed
# Conditions: If no value is given, no further constraining on the value surrogate can be made. 

# --> In RDF, dsp:NonLiteralStatementTemplate and dsp:LiteralStatementTemplate can be stated as types of statement templates.
# --> There is no constraint in RDF

# -----

# ---------------
# Property Constraints - Property List Constraint [done] 


# Summary: A set of properties that are allowed in this statement template. 
# Allowed values: a list of property URIs 
# Default: N/A 
# Conditions: cannot occur together with a sub-property constraint

# -----
dsp2spin:PropertyConstraints_PropertyListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
					
#           FILTER ( ?property != dcam:memberOf ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 dcam:memberOf ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#			FILTER EXISTS { ?statementTemplate dsp:property ?p . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "statementTemplate" ] ;
                            sp:predicate dsp:property ;
                            sp:object [ sp:varName "p" ] ] ) ] ]
				
#			FILTER NOT EXISTS { ?statementTemplate dsp:property ?property . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "statementTemplate" ] ;
                            sp:predicate dsp:property ;
                            sp:object [ sp:varName "property" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "property ( " ;
					sp:arg2 [ sp:varName "property" ] ;
					sp:arg3 " ) not allowed for description template ( " ;
					sp:arg4 [ sp:varName "descriptionTemplate" ] ;
					sp:arg5 " )" ] ] ) ].
	
# A property list constraint cannot occur together with a sub-property constraint	
# -----
dsp2spin:PropertyConstraints_PropertyListConstraint_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#			FILTER EXISTS { ?statementTemplate dsp:property ?p1 . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "statementTemplate" ] ;
                            sp:predicate dsp:property ;
                            sp:object [ sp:varName "p1" ] ] ) ] ]
				
#			FILTER EXISTS { ?statementTemplate dsp:subPropertyOf ?p2 . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "statementTemplate" ] ;
                            sp:predicate dsp:subPropertyOf ;
                            sp:object [ sp:varName "p2" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "A property list constraint cannot occur together with a sub-property constraint" ;
					sp:arg2 " | description template: " ;
					sp:arg3 [ sp:varName "this" ] ;
					sp:arg4 " )" ] ] ) ].

# -----

# ---------------
# Property Constraints - Sub-Property Constraint [done] 


# Summary: Only sub-properties of the given property are allowed in this statement template. 
# Note that the given property is included in this list (all properties are sub-properties of themselves). 
# Allowed values: a property URI
# Default: N/A 
# Conditions: cannot occur together with a property list constraint 

# dsp:minOccur
# dsp:maxOccur

dsp2spin:PropertyConstraints_Sub-PropertyConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?subProperty ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "subProperty" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?subProperty != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "subProperty" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:subPropertyOf ?superProperty .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:subPropertyOf ;
				sp:object [ sp:varName "superProperty" ] ]
				
#           FILTER ( ?subProperty != ?superProperty ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
					sp:arg1 [ sp:varName "subProperty" ] ;
					sp:arg2 [ sp:varName "superProperty" ] ] ]
				
#           FILTER NOT EXISTS { ?subProperty rdfs:subPropertyOf ?superProperty }
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:notExists ;
					sp:elements ( 
						[   sp:subject [ sp:varName "subProperty" ] ;
							sp:predicate rdfs:subPropertyOf ;
							sp:object [ sp:varName "superProperty" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 [ sp:varName "subProperty" ] ;
					sp:arg2 " is not a sub-property of the super-property ( " ;
					sp:arg3 [ sp:varName "superProperty" ] ;
					sp:arg4 " ) defined in the description template ( " ;
					sp:arg5 [ sp:varName "descriptionTemplate" ] ;
					sp:arg6 " )" ] ] ) ].

# -----

# ---------------
# Literal Value Constraints - Literal List Constraint [done]


# Summary: Literals that are allowed as values. 
# Allowed values: a list of literals, i.e. (string, language tag) or (string, syntax encoding scheme URI) pairs. 
# Default: no constraint 
# Conditions: if given, no other literal constraint may be given 


# -----
dsp2spin:LiteralValueConstraints_LiteralListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#			FILTER EXISTS { ?literalConstraint dsp:literal ?l }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "l" ] ] ) ] ]
				
#			FILTER NOT EXISTS { ?literalConstraint dsp:literal ?literal }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "literal ( " ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 " ) not allowed for description template ( " ;
					sp:arg4 [ sp:varName "descriptionTemplate" ] ;
					sp:arg5 " )" ] ] ) ].
	
# As a literal list constraint is given, no literal language constraint can be given	
# -----
dsp2spin:LiteralValueConstraints_LiteralListConstraint_LiteralLanguageConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#			FILTER EXISTS { 
#               ?this ?property ?literal .
#               FILTER ( ?property != rdf:type ) . 
#               ?literalConstraint dsp:literal ?literal . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate [ sp:varName "property" ] ;
							sp:object [ sp:varName "literal" ] ]
						[   a sp:Filter ;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "property" ] ;
								sp:arg2 rdf:type ] ]
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]
							
#			FILTER EXISTS { ?literalConstraint dsp:languageOccurrence ?languageOccurrence }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:languageOccurrence ;
                            sp:object [ sp:varName "languageOccurrence" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As a literal list constraint is given, no literal language constraint can be given as specified in description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# As a literal list constraint is given, no literal language list constraint can be given	
# -----
dsp2spin:LiteralValueConstraints_LiteralListConstraint_LiteralLanguageListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#			FILTER EXISTS { 
#               ?this ?property ?literal .
#               FILTER ( ?property != rdf:type ) . 
#               ?literalConstraint dsp:literal ?literal . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate [ sp:varName "property" ] ;
							sp:object [ sp:varName "literal" ] ]
						[   a sp:Filter ;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "property" ] ;
								sp:arg2 rdf:type ] ]
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]
							
#			FILTER EXISTS { ?literalConstraint dsp:language ?language }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:language ;
                            sp:object [ sp:varName "language" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As a literal list constraint is given, no literal language list constraint can be given as specified in description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# As a literal list constraint is given, no syntax encoding scheme constraint can be given	
# -----
dsp2spin:LiteralValueConstraints_LiteralListConstraint_SyntaxEncodingSchemeConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#			FILTER EXISTS { 
#               ?this ?property ?literal .
#               FILTER ( ?property != rdf:type ) . 
#               ?literalConstraint dsp:literal ?literal . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate [ sp:varName "property" ] ;
							sp:object [ sp:varName "literal" ] ]
						[   a sp:Filter ;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "property" ] ;
								sp:arg2 rdf:type ] ]
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]
							
#			FILTER EXISTS { ?literalConstraint dsp:syntaxEncodingSchemeOccurrence ?syntaxEncodingSchemeOccurrence }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
                            sp:object [ sp:varName "syntaxEncodingSchemeOccurrence" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As a literal list constraint is given, no syntax encoding scheme constraint can be given as specified in description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# As a literal list constraint is given, no syntax encoding scheme list constraint can be given	
# -----
dsp2spin:LiteralValueConstraints_LiteralListConstraint_SyntaxEncodingSchemeListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#			FILTER EXISTS { 
#               ?this ?property ?literal .
#               FILTER ( ?property != rdf:type ) . 
#               ?literalConstraint dsp:literal ?literal . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate [ sp:varName "property" ] ;
							sp:object [ sp:varName "literal" ] ]
						[   a sp:Filter ;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "property" ] ;
								sp:arg2 rdf:type ] ]
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]
							
#			FILTER EXISTS { ?literalConstraint dsp:syntaxEncodingScheme ?syntaxEncodingScheme }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "syntaxEncodingScheme" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As a literal list constraint is given, no syntax encoding scheme list constraint can be given as specified in description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].

# -----

# ---------------
# Literal Value Constraints - Literal Language Constraint [done]


# Summary: Whether languages are allowed for the literal 
# Allowed values: mandatory, optional, disallowed 
# Default: optional
# Conditions: if "mandatory", Syntax encoding schemes are automatically disallowed 


# mandatory
# -----
dsp2spin:LiteralValueConstraints_LiteralLanguageConstraint_Mandatory
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:languageOccurrence ?languageOccurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:languageOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
					
#			FILTER ( ?language = "" ) .
#           -----   
			[   a sp:Filter ;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "language" ] ;
					sp:arg2 "" ] ]	

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "language mandatory for literal ( '" ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 "')" ] ] ) ].
					
# if "mandatory", syntax encoding schemes are automatically disallowed 
# -----
dsp2spin:LiteralValueConstraints_LiteralLanguageConstraint_Mandatory_SyntaxEncodingSchemes
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:languageOccurrence ?languageOccurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:languageOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]
				
#           BIND ( ( datatype ( ?literal ) ) AS ?datatype ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "literal" ] ] ] 

#           FILTER ( ?datatype != rdf:langString ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "datatype" ] ;
					sp:arg2 rdf:langString ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As the literal language constraint is mandatory, syntax encoding schemes are automatically disallowed for literal ( " ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 " ) as specified in description template ( " ;
					sp:arg4 [ sp:varName "descriptionTemplate" ] ;
					sp:arg5 " )" ] ] ) ].
				
# disallowed				
# -----
dsp2spin:LiteralValueConstraints_LiteralLanguageConstraint_Disallowed
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:languageOccurrence ?languageOccurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:languageOccurrence ;
				sp:object "disallowed"^^dsp:occurrence ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
					
#			FILTER ( ?language != "" ) .
#           -----   
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "language" ] ;
					sp:arg2 "" ] ]	

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "languages not allowed for literal ( '" ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 "'@" ;
					sp:arg4 [ sp:varName "language" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# --------------
# Literal Value Constraints - Literal Language List Constraint [done]


# Summary: languages allowed for the literal 
# Allowed values: a list consisting of language tags 
# Default: no constraint  


# -----
dsp2spin:LiteralValueConstraints_LiteralLanguageListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
	
#           FILTER EXISTS { ?literalConstraint dsp:language ?languageDef . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:language ;
                            sp:object [ sp:varName "languageDef" ] ] ) ] ]

#           FILTER NOT EXISTS { 
#               ?literalConstraint dsp:language ?languageDefinition . 
#               BIND( ( IF( ?language^^xsd:string = ?languageDefinition^^xsd:string, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?match ) .
#               FILTER ( ?match = "true"^^xsd:boolean ) . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:language ;
                            sp:object [ sp:varName "languageDefinition" ] ] 	
						[   a sp:Bind ;
							sp:expression [
								a sp:if ;
								sp:arg1 [ 
									a sp:eq ;
									sp:arg1 [ sp:varName "language"^^xsd:string ] ;
									sp:arg2 [ sp:varName "languageDefinition"^^xsd:string ] ] ;
								sp:arg2 "true"^^xsd:boolean ;
								sp:arg3 "false"^^xsd:boolean ] ;
							sp:variable [ sp:varName "match"^^xsd:boolean ] ] 
						[   a sp:Filter ;
							sp:expression [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "match"^^xsd:boolean ] ;
								sp:arg2 "true"^^xsd:boolean ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
				[   a sp:Bind;
					sp:variable [ sp:varName "violationMessage" ];
					sp:expression [ 
						a fn:concat; 
						sp:arg1 "The language ( " ;
						sp:arg2 [ sp:varName "language" ] ;
						sp:arg3 " ) is not allowed for the literal ( " ;
						sp:arg4 [ sp:varName "literal" ] ;
						sp:arg5 " )" ] ] ) ].
					
# testing
# -----
dsp2spin:LiteralValueConstraints_LiteralLanguageListConstraint_Testing
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 

#           testing
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "languageDatatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "language" ] ] ] 
			[   sp:subject [ sp:varName "literalConstraint" ] ;
				sp:predicate dsp:language ;
				sp:object [ sp:varName "languageDefinition" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "languageDefinitionDatatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "languageDefinition" ] ] ] 
			[   a sp:Bind;
				sp:variable [ sp:varName "languageDefinitionStr" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "languageDefinition" ] ] ] 
			[   a sp:Bind;
				sp:variable [ sp:varName "languageDefinitionStrDatatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "languageDefinitionStr" ] ] ] 	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "language"^^xsd:string ] ;
						sp:arg2 [ sp:varName "languageDefinitionStr"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "match"^^xsd:boolean ] ] 
#			-----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "literal: " ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 " | language: " ;
					sp:arg4 [ sp:varName "language" ] ;
					sp:arg5 " | datatype (language): " ;
					sp:arg6 [ sp:varName "languageDatatype" ] ;
					sp:arg7 " | language definition: " ;
					sp:arg8 [ sp:varName "languageDefinition" ] ;
					sp:arg9 " | datatype (language definition): " ;
					sp:arg10 [ sp:varName "languageDefinitionDatatype" ] ;
					sp:arg11 " | str (language definition): " ;
					sp:arg12 [ sp:varName "languageDefinitionStr" ] ;
					sp:arg13 " | datatype (str (language definition)): " ;
					sp:arg14 [ sp:varName "languageDefinitionStrDatatype" ] ;
					sp:arg15 " | match: " ;
					sp:arg16 [ sp:varName "match" ] ;
					sp:arg17 " )" ] ] ) ].

# -----

# ---------------
# Literal Value Constraints - Syntax Encoding Scheme Constraint [done]


# Summary: Whether Syntax Encoding Schemes are allowed for the literal [done]
# Allowed values: mandatory, optional, disallowed [done]
# Default: optional --> no constraint needed [done]
# Conditions: if "mandatory", language tags are automatically disallowed. [done]

# limitations
# - If there is no datatype IRI and no language tag, the datatype is xsd:string
# - If there is a language tag, the datatype is rdf:langString


# mandatory
# - no datatype and language tag --> datatype = rdf:langString 
# - no datatype IRI and no language tag --> datatype = xsd:string
# --> no constraint needed
# -----
dsp2spin:LiteralValueConstraints_SyntaxEncodingSchemeConstraint_Mandatory
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
				
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object _:violationSource ] 
			[   sp:subject _:violationSource ;
				sp:predicate rdf:type ;
				sp:object rdfs:Resource ]
			[   sp:subject _:violationSource ; 
				sp:predicate rdfs:label ;
				sp:object "violationSource" ] 
				
#			[   sp:subject _:violation ;
#				sp:predicate spin:violationSource ;
#				sp:object [ sp:varName "violationSource" ] ] 
			) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:syntaxEncodingSchemeOccurrence "mandatory"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]				

#           FILTER NOT EXISTS { ?literalConstraint dsp:syntaxEncodingScheme ?syntaxEncodingScheme . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "syntaxEncodingScheme" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax Encoding Schemes are mandatory as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# disallowed
# -----
dsp2spin:LiteralValueConstraints_SyntaxEncodingSchemeConstraint_Disallowed
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
				
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object _:violationSource ] 
			[   sp:subject _:violationSource ;
				sp:predicate rdf:type ;
				sp:object rdfs:Resource ]
			[   sp:subject _:violationSource ; 
				sp:predicate rdfs:label ;
				sp:object "violationSource" ] 
				
#			[   sp:subject _:violation ;
#				sp:predicate spin:violationSource ;
#				sp:object [ sp:varName "violationSource" ] ] 
			) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:syntaxEncodingSchemeOccurrence "disallowed"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
				sp:object "disallowed"^^dsp:occurrence ]				

#           FILTER EXISTS { ?literalConstraint dsp:syntaxEncodingScheme ?syntaxEncodingScheme . }
#           -----
#			[   a sp:Filter ;
#                sp:expression [ 
#					a sp:exists ;
#                    sp:elements ( 
#						[   sp:subject [ sp:varName "literalConstraint" ] ;
#                            sp:predicate dsp:syntaxEncodingScheme ;
#                            sp:object [ sp:varName "syntaxEncodingScheme" ] ] ) ] ]
							
							
#           FILTER EXISTS { ?this ?property ?l . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "property" ] ;
                            sp:object [ sp:varName "l" ] ] ) ] ]		
							
#           language tag --> datatype = rdf:langString 
#           no datatype IRI and no language tag --> datatype = xsd:string
#           -----
#           FILTER EXISTS { 
#               ?this ?property ?literal .
#               BIND( ( IF( sp:datatype( ?literal^^xsd:string ) = rdf:langString || sp:datatype( ?literal ) = xsd:string, "false"^^xsd:boolean, "true"^^xsd:boolean ) ) AS ?isSyntaxEncodingScheme^^xsd:boolean ) .
#               FILTER ( ?isSyntaxEncodingScheme = "true"^^xsd:boolean ) . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 	
					    [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "property" ] ;
                            sp:object [ sp:varName "literal" ] ]
						[   a sp:Bind ;
							sp:expression [
								a sp:if ;
								sp:arg1 [ 
									a sp:or ;
									sp:arg1 [
										a sp:eq ;
										sp:arg1 [ 
											a sp:datatype;
											sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
										sp:arg2 rdf:langString ] ;
									sp:arg2 [
										a sp:eq ;
										sp:arg1 [ 
											a sp:datatype;
											sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
										sp:arg2 xsd:string ] ] ;
								sp:arg2 "false"^^xsd:boolean ;
								sp:arg3 "true"^^xsd:boolean ] ;
							sp:variable [ sp:varName "isSyntaxEncodingScheme"^^xsd:boolean ] ] 
						[   a sp:Filter ;
							sp:expression [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isSyntaxEncodingScheme"^^xsd:boolean ] ;
								sp:arg2 "true"^^xsd:boolean ] ] ) ] ]
							

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax Encoding Schemes are disallowed as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# if "mandatory", language tags are automatically disallowed
# -----
dsp2spin:LiteralValueConstraints_SyntaxEncodingSchemeConstraint_LanguageTags
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
				
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object _:violationSource ] 
			[   sp:subject _:violationSource ;
				sp:predicate rdf:type ;
				sp:object rdfs:Resource ]
			[   sp:subject _:violationSource ; 
				sp:predicate rdfs:label ;
				sp:object "violationSource" ] 
				
#			[   sp:subject _:violation ;
#				sp:predicate spin:violationSource ;
#				sp:object [ sp:varName "violationSource" ] ] 
			) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:syntaxEncodingSchemeOccurrence "mandatory"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]	
				
#           FILTER EXISTS { 
#               ?this ?property ?literal .
#               BIND ( ( lang ( ?literal ) ) AS ?language ) .
#               BIND( ( IF( ?language^^xsd:string != ""^^xsd:string, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLanguage ) .
#               FILTER ( ?isLanguage = "true"^^xsd:boolean ) . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate [ sp:varName "property" ] ;
							sp:object [ sp:varName "literal" ] ]
						[   a sp:Bind;
							sp:variable [ sp:varName "language" ];
							sp:expression [
								a sp:lang;
								sp:arg1 [ sp:varName "literal" ] ] ] 	
						[   a sp:Bind ;
							sp:expression [
								a sp:if ;
								sp:arg1 [ 
									a sp:ne ;
									sp:arg1 [ sp:varName "language"^^xsd:string ] ;
									sp:arg2 ""^^xsd:string ] ;
								sp:arg2 "true"^^xsd:boolean ;
								sp:arg3 "false"^^xsd:boolean ] ;
							sp:variable [ sp:varName "isLanguage"^^xsd:boolean ] ] 
						[   a sp:Filter ;
							sp:expression [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isLanguage"^^xsd:boolean ] ;
								sp:arg2 "true"^^xsd:boolean ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax Encoding Schemes are mandatory and language tags are automatically disallowed as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].

# -----

# ---------------
# Literal Value Constraints - Syntax Encoding Scheme List Constraint [done]


# Summary: Syntax encoding schemes allowed for the literal 
# Allowed values: a list consisting of syntax encoding scheme URIs 
# Default: no constraint 


# -----
dsp2spin:LiteralValueConstraints_SyntaxEncodingSchemeListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           BIND ( ( datatype ( ?literal ) ) AS ?datatype ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "literal" ] ] ] 
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           FILTER EXISTS { ?literalConstraint dsp:syntaxEncosingScheme ?ses . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "ses" ] ] ) ] ]

#           FILTER NOT EXISTS { ?literalConstraint dsp:syntaxEncosingScheme ?datatype . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "datatype" ] ] ) ] ]

#    		testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "violationMessage" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "literal: " ;
#					sp:arg2 [ sp:varName "literal" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " )" ] ] ) ].

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax encoding schemes ( " ;
					sp:arg2 [ sp:varName "datatype" ] ;
					sp:arg3 " ) not allowed for the literal ( " ;
					sp:arg4 [ sp:varName "literal" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Description Template Reference [done]


# Summary: A reference to a description template that may be used to describe the value 
# Allowed values: an identifier defined in a Description Template 
# Default: Related description not allowed 
# Conditions: if given, any related description of the value within the record must match the referenced Description Template. 
#             If the referenced Description Template contains mandatory Statement templates, such a description of the value must exist. 


# does value description template correspond to the value desctription template defined in the subject description template
# -----
dsp2spin:NonLiteralValueConstraints_DescriptionTemplateReference
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	

#           subject:
#           -----

#               ?this rdf:type ?resourceClassSubject .
#               -----
		    	[   sp:subject [ sp:varName "this" ] ;
		    	    sp:predicate rdf:type ;
			    	sp:object [ sp:varName "resourceClassSubject" ] ]
				
#           	?this ?property ?object .
#           	-----
				[   sp:subject [ sp:varName "this" ] ;
					sp:predicate [ sp:varName "property" ] ;
					sp:object [ sp:varName "object" ] ]
				
#           	FILTER ( ?property != rdf:type ) .
#               -----
				[   a sp:Filter ;
					sp:expression [ 
						a sp:ne;
						sp:arg1 [ sp:varName "property" ] ;
						sp:arg2 rdf:type ] ]
				
#		    	?descriptionTemplateSubject rdf:type dsp:DescriptionTemplate .
#          		-----
				[   sp:subject [ sp:varName "descriptionTemplateSubject" ] ;
					sp:predicate rdf:type ;
					sp:object dsp:DescriptionTemplate ]
				
#        	    ?descriptionTemplateSubject dsp:resourceClass ?resourceClassSubject .
#        	    -----
				[   sp:subject [ sp:varName "descriptionTemplateSubject" ] ;
					sp:predicate dsp:resourceClass ;
					sp:object [ sp:varName "resourceClassSubject" ] ]
					
#        	    ?descriptionTemplateSubject dsp:statementTemplate ?statementTemplateSubject .
#        	    -----
				[   sp:subject [ sp:varName "descriptionTemplateSubject" ] ;
					sp:predicate dsp:statementTemplate ;
					sp:object [ sp:varName "statementTemplateSubject" ] ]

#          		?statementTemplateSubject dsp:property ?property .
#           	-----
				[   sp:subject [ sp:varName "statementTemplateSubject" ] ;
					sp:predicate dsp:property ;
					sp:object [ sp:varName "property" ] ]
				
#           	?statementTemplateSubject dsp:nonLiteralConstraint ?nonLiteralConstraintSubject .
#           	-----
				[   sp:subject [ sp:varName "statementTemplateSubject" ] ;
					sp:predicate dsp:nonLiteralConstraint ;
					sp:object [ sp:varName "nonLiteralConstraintSubject" ] ]
					
#           	?nonLiteralConstraintSubject dsp:descriptionTemplate ?descriptionTemplateObjectReference .
#           	-----
				[   sp:subject [ sp:varName "nonLiteralConstraintSubject" ] ;
					sp:predicate dsp:descriptionTemplate ;
					sp:object [ sp:varName "descriptionTemplateObjectReference" ] ]
				
#           object:
#           -----

#           	?object rdf:type ?resourceClassObject .
#          	 	-----
				[   sp:subject [ sp:varName "object" ] ;
					sp:predicate rdf:type ;
					sp:object [ sp:varName "resourceClassObject" ] ]
					
#		    	?descriptionTemplateObject rdf:type dsp:DescriptionTemplate .
#          		-----
				[   sp:subject [ sp:varName "descriptionTemplateObject" ] ;
					sp:predicate rdf:type ;
					sp:object dsp:DescriptionTemplate ]
				
#        	    ?descriptionTemplateObject dsp:resourceClass ?resourceClassObject .
#        	    -----
				[   sp:subject [ sp:varName "descriptionTemplateObject" ] ;
					sp:predicate dsp:resourceClass ;
					sp:object [ sp:varName "resourceClassObject" ] ]
			
#           condition:
#           -----
			
#           	FILTER ( ?descriptionTemplateObjectReference != ?descriptionTemplateObject ) .
#           	-----
				[   a sp:Filter ;
					sp:expression [ 
						a sp:ne;
						sp:arg1 [ sp:varName "descriptionTemplateObjectReference" ] ;
						sp:arg2 [ sp:varName "descriptionTemplateObject" ] ] ]
				
#    		testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "violationMessage" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "literal: " ;
#					sp:arg2 [ sp:varName "literal" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " )" ] ] ) ].

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Value description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplateObject" ] ;
					sp:arg3 " ) does not correspond to the value desctription template (" ;
					sp:arg4 [ sp:varName "descriptionTemplateObjectReference" ] ;
					sp:arg5 " ) defined in the subject description template" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Class Membership Constraint [done]


# Summary: Classes that the value may be an instance of 
# Allowed values: a list of class URIs 
# Default: no constraint 
# Conditions: if given, the value must be an instance of one of the given classes.   


dsp2spin:NonLiteralValueConstraints_ClassMembershipConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueClass ?valueClass .
#           -----
#			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
#			    sp:predicate dsp:valueClass ;
#				sp:object [ sp:varName "valueClass" ] ]				
				
#           FILTER EXISTS { ?nonLiteralConstraint dsp:valueClass ?valueClass . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
                            sp:predicate dsp:valueClass ;
                            sp:object [ sp:varName "valueClass" ] ] ) ] ]

#           FILTER NOT EXISTS { ?object rdf:type ?valueClass . ?nonLiteralConstraint dsp:valueClass ?valueClass . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "valueClass" ] ]
						[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
                            sp:predicate dsp:valueClass ;
                            sp:object [ sp:varName "valueClass" ] ]
						) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The value ( " ;
					sp:arg2 [ sp:varName "object" ] ;
					sp:arg3 " ) is not an instance of one of the value URIs specified by the description template ( " ;
					sp:arg4 [ sp:varName "descriptionTemplate" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Value URI Occurrence Constraint [done]


# Summary: Whether a value URI must be given 
# Allowed values: "disallowed", "optional", "mandatory" 
# Default: "optional"  


# mandatory
# -----
dsp2spin:NonLiteralValueConstraints_ValueURIOccurrenceConstraint_Mandatory
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueURIOccurrence "mandatory"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueURIOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]				

#           FILTER NOT EXISTS { ?nonLiteralConstraint dsp:valueURI ?valueURI . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
                            sp:predicate dsp:valueURI ;
                            sp:object [ sp:varName "valueURI" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "A value URI must be given as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
		
# disallowed
# -----		
dsp2spin:NonLiteralValueConstraints_ValueURIOccurrenceConstraint_Disallowed
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueURIOccurrence "disallowed"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueURIOccurrence ;
				sp:object "disallowed"^^dsp:occurrence ]				

#           FILTER EXISTS { ?nonLiteralConstraint dsp:valueURI ?valueURI . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
                            sp:predicate dsp:valueURI ;
                            sp:object [ sp:varName "valueURI" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Value URIs are not allowed as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Value URI List Constraint [done]


# Summary: URIs that are allowed as value URIs. 
# Allowed values: a list of URIs 
# Default: no constraint 
# Conditions: If a value URI is given, it must be taken from this list. Cannot be specified if value occurrence is "disallowed"  


dsp2spin:Non-LiteralValueConstraints_ValueURIListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#			FILTER EXISTS { ?nonLiteralConstraint dsp:valueURI ?valueURI . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
                            sp:predicate dsp:valueURI ;
                            sp:object [ sp:varName "valueURI" ] ] ) ] ]
				
#			FILTER NOT EXISTS { ?nonLiteralConstraint dsp:valueURI ?object . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "?nonLiteralConstraint" ] ;
                            sp:predicate dsp:valueURI ;
                            sp:object [ sp:varName "object" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "value URI ( " ;
					sp:arg2 [ sp:varName "this" ] ;
					sp:arg3 " not allowed for description template ( " ;
					sp:arg4 [ sp:varName "descriptionTemplate" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Vocabulary Encoding Scheme Occurrence Constraint [done]


# Summary: Whether a vocabulary encoding scheme must be given 
# Allowed values: "disallowed", "optional", "mandatory" 
# Default: "optional" --> no constraint needed


# mandatory
# -----
dsp2spin:NonLiteralValueConstraints_VocabularyEncodingSchemeOccurrenceConstraint_Mandatory
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:vocabularyEncodingSchemeOccurrence "mandatory"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:vocabularyEncodingSchemeOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]				

#           FILTER NOT EXISTS { ?nonLiteralConstraint dsp:vocabularyEncodingScheme ?ves . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
                            sp:predicate dsp:vocabularyEncodingScheme ;
                            sp:object [ sp:varName "ves" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "A vocabulary encoding scheme must be given as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# disallowed
# -----
dsp2spin:NonLiteralValueConstraints_VocabularyEncodingSchemeOccurrenceConstraint_Disallowed
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:vocabularyEncodingSchemeOccurrence "disallowed"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:vocabularyEncodingSchemeOccurrence ;
				sp:object "disallowed"^^dsp:occurrence ]				

#           FILTER EXISTS { ?nonLiteralConstraint dsp:vocabularyEncodingScheme ?ves . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
                            sp:predicate dsp:vocabularyEncodingScheme ;
                            sp:object [ sp:varName "ves" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Vocabulary encoding schemes are not allowed as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# Allowed values: "disallowed"^^dsp:occurrence, "optional"^^dsp:occurrence, "mandatory"^^dsp:occurrence 
# -----
dsp2spin:NonLiteralValueConstraints_VocabularyEncodingSchemeOccurrenceConstraint_AllowedValues
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {		
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:vocabularyEncodingSchemeOccurrence ?vocabularyEncodingSchemeOccurrence .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:vocabularyEncodingSchemeOccurrence ;
				sp:object [ sp:varName "vocabularyEncodingSchemeOccurrence" ] ]		

#           BIND ( ( str ( ?vocabularyEncodingSchemeOccurrence ) ) AS ?vocabularyEncodingSchemeOccurrenceStr ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "vocabularyEncodingSchemeOccurrenceStr" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "vocabularyEncodingSchemeOccurrence" ] ] ] 

#           BIND ( ( datatype ( ?vocabularyEncodingSchemeOccurrence ) ) AS ?datatype ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "vocabularyEncodingSchemeOccurrence" ] ] ] 	

#           FILTER ( 
#               (   ?vocabularyEncodingSchemeOccurrenceStr^^xsd:string != "disallowed"^^xsd:string && 
#                   ?vocabularyEncodingSchemeOccurrenceStr^^xsd:string != "optional"^^xsd:string && 
#                   ?vocabularyEncodingSchemeOccurrenceStr^^xsd:string != "mandatory"^^xsd:string )
#			    ||
#                   ?datatype^^xsd:string != dsp:occurrence ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
				    a sp:or ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:and ;
                            sp:arg1 [ 
								a sp:ne ;
                                sp:arg1 [ sp:varName "vocabularyEncodingSchemeOccurrenceStr"^^xsd:string ] ;
                                sp:arg2 "disallowed"^^xsd:string ] ;
                            sp:arg2 [
								a sp:ne ;
                                sp:arg1 [ sp:varName "vocabularyEncodingSchemeOccurrenceStr"^^xsd:string ] ;
                                sp:arg2 "optional"^^xsd:string ] ] ;
                        sp:arg2 [ 
							a sp:ne ;
                            sp:arg1 [ sp:varName "vocabularyEncodingSchemeOccurrenceStr"^^xsd:string ] ;
                            sp:arg2 "mandatory"^^xsd:string ] ] ;
                    sp:arg2 [ 
						a sp:ne ;
                        sp:arg1 [ sp:varName "datatype"^^xsd:string ] ;
                        sp:arg2 dsp:occurrence ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The vocabulary encoding scheme occurrence value ( " ;
					sp:arg2 [ sp:varName "vocabularyEncodingSchemeOccurrenceStr" ] ;
					sp:arg3 "^^" ;
					sp:arg4 [ sp:varName "datatype" ] ;
					sp:arg5 " ) is not one of the allowed vocabulary encoding scheme occurrence values ( 'disallowed'^^dsp:occurrence, 'optional'^^dsp:occurrence, 'mandatory'^^dsp:occurrence )" ] ] ) ].	

# -----

# ---------------
# Non-Literal Value Constraints - Vocabulary Encoding Scheme List Constraint [done]


# Summary: URIs that are allowed as Vocabulary Encoding schemes. 
# Allowed values: a list of URIs 
# Default: no constraint 
# Conditions: If a vocabulary encoding scheme is given, it must be taken from this list. Cannot be specified if vocabulary encoding scheme occurrence is "disallowed"


# -----
dsp2spin:Non-LiteralValueConstraints_VocabularyEncodingSchemeListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
					
#           ?object dcam:memberOf ?ves .
#           -----
			[   sp:subject [ sp:varName "object" ] ;
			    sp:predicate dcam:memberOf ;
				sp:object [ sp:varName "ves" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#			FILTER EXISTS { ?nonLiteralConstraint dsp:vocabularyEncodingScheme ?vocabES . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
                            sp:predicate dsp:vocabularyEncodingScheme ;
                            sp:object [ sp:varName "vocabES" ] ] ) ] ]
				
#			FILTER NOT EXISTS { ?nonLiteralConstraint dsp:vocabularyEncodingScheme ?ves . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "?nonLiteralConstraint" ] ;
                            sp:predicate dsp:vocabularyEncodingScheme ;
                            sp:object [ sp:varName "ves" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The vocabulary encoding scheme ( " ;
					sp:arg2 [ sp:varName "ves" ] ;
					sp:arg3 " ) is not allowed for description template ( " ;
					sp:arg4 [ sp:varName "descriptionTemplate" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Minimum Occurrence Constraint [done]


# Summary: The minimum number of times this kind of value string must appear in the enclosing Statement.
# Allowed values: non-negative integer 
# Default: 0 [--> no constraint needed]
# Conditions: must be equal or less than the Maximum occurrence 


# -----
dsp2spin:Non-LiteralValueConstraints_MinimumOccurrenceConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]
				
#           ?valueStringConstraint dsp:minOccur ?minCardinality .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minCardinality" ] ]
				
#	    	cardinality < minCardinality
#	    	-----
#	    	BIND ( ( spl:objectCount ( ?object, rdf:value ) ) AS ?cardinality ) . }
#			FILTER ( cardinality < ?minCardinality ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinality" ] ;
				sp:expression [
					a spl:objectCount ;
					sp:arg1 [ sp:varName "object" ] ;
					sp:arg2 rdf:value ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "cardinality" ] ;
					sp:arg2 [ sp:varName "minCardinality" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Cardinality of value strings ( " ;
					sp:arg2 [ sp:varName "cardinality" ] ;
					sp:arg3 " ) < min cardinality of value strings ( " ;
					sp:arg4 [ sp:varName "minCardinality" ] ;
					sp:arg5 " ) as specified in description template ( " ;
					sp:arg6 [ sp:varName "descriptionTemplate" ] ;
					sp:arg7 " )" ] ] ) ].
					
# dsp:minOccur <= dsp:maxOccur
# -----
dsp2spin:Non-LiteralValueConstraints_MinimumOccurrenceConstraint_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]
				
#           ?valueStringConstraint dsp:minOccur ?minCardinality .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minCardinality" ] ]
				
#           ?valueStringConstraint dsp:maxOccur ?maxCardinality .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxCardinality" ] ]
				
#			FILTER ( ?minCardinality > ?maxCardinality ) .
#           -----	    
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "minCardinality" ] ;
					sp:arg2 [ sp:varName "maxCardinality" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Min cardinality of value strings ( " ;
					sp:arg2 [ sp:varName "minCardinality" ] ;
					sp:arg3 " ) > max cardinality of value strings ( " ;
					sp:arg4 [ sp:varName "maxCardinality" ] ;
					sp:arg5 " ) as specified in description template ( " ;
					sp:arg6 [ sp:varName "this" ] ;
					sp:arg7 " )" ] ] ) ].
					
# Allowed values: non-negative integer
# -----
dsp2spin:Non-LiteralValueConstraints_MinimumOccurrenceConstraint_AllowedValues
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {		
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]
				
#           ?valueStringConstraint dsp:minOccur ?minCardinality .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minCardinality" ] ]
				
#           BIND ( ( datatype ( ?minCardinality ) ) AS ?datatype ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "minCardinality" ] ] ] 
				
#           BIND( ( IF( sp:isNumeric ( ?minCardinality ), "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isNumeric ) .
#           FILTER ( ?isNumeric = "false"^^xsd:boolean ) . 
#           -----	
			[   a sp:Bind ;
				sp:expression [
					a sp:if ;
					sp:arg1 [ 
						a sp:isNumeric ;
						sp:arg1 [ sp:varName "minCardinality"^^xsd:string ] ] ;
					sp:arg2 "true"^^xsd:boolean ;
					sp:arg3 "false"^^xsd:boolean ] ;
				sp:variable [ sp:varName "isNumeric"^^xsd:boolean ] ] 
			[   a sp:Filter ;
				sp:expression [ 
					a sp:eq ;
					sp:arg1 [ sp:varName "isNumeric"^^xsd:boolean ] ;
					sp:arg2 "false"^^xsd:boolean ] ] 

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The value string minimum occurrence constraint ( " ;
					sp:arg2 [ sp:varName "minCardinality" ] ;
					sp:arg3 "^^" ;
					sp:arg4 [ sp:varName "datatype" ] ;
					sp:arg5 " ) is not a non-negative integer as specified by the description template ( " ;
					sp:arg6 [ sp:varName "this" ] ;
					sp:arg7 " )" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Maximum Occurrence Constraint


# Summary: The maximum number of times this kind of value string is allowed to appear in the enclosing Statement. 
# Allowed values: non-negative integer or "infinity" 
# Default: "infinity" [--> no constraint needed]
# Conditions: must be equal or greater than the Minimum occurrence 


# -----
dsp2spin:Non-LiteralValueConstraints_MaximumOccurrenceConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]
				
#           ?valueStringConstraint dsp:maxOccur ?maxCardinality .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxCardinality" ] ]
				
#	    	cardinality > maxCardinality
#	    	-----
#	    	BIND ( ( spl:objectCount ( ?object, rdf:value ) ) AS ?cardinality ) . }
#			FILTER ( cardinality > ?maxCardinality ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinality" ] ;
				sp:expression [
					a spl:objectCount ;
					sp:arg1 [ sp:varName "object" ] ;
					sp:arg2 rdf:value ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "cardinality" ] ;
					sp:arg2 [ sp:varName "maxCardinality" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Cardinality of value strings ( " ;
					sp:arg2 [ sp:varName "cardinality" ] ;
					sp:arg3 " ) > max cardinality of value strings ( " ;
					sp:arg4 [ sp:varName "maxCardinality" ] ;
					sp:arg5 " ) as specified in description template ( " ;
					sp:arg6 [ sp:varName "descriptionTemplate" ] ;
					sp:arg7 " )" ] ] ) ].
					
# Allowed values: non-negative integer or "infinity" 
# -----
dsp2spin:Non-LiteralValueConstraints_MaximumOccurrenceConstraint_AllowedValues
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]
				
#           ?valueStringConstraint dsp:minOccur ?maxCardinality .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxCardinality" ] ]
				
#           BIND ( ( datatype ( ?maxCardinality ) ) AS ?datatype ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "maxCardinality" ] ] ] 
				
#           BIND( ( IF( sp:isNumeric ( ?maxCardinality ), "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isNumeric ) .
#           -----	
			[   a sp:Bind ;
				sp:expression [
					a sp:if ;
					sp:arg1 [ 
						a sp:isNumeric ;
						sp:arg1 [ sp:varName "maxCardinality"^^xsd:string ] ] ;
					sp:arg2 "true"^^xsd:boolean ;
					sp:arg3 "false"^^xsd:boolean ] ;
				sp:variable [ sp:varName "isNumeric"^^xsd:boolean ] ] 
	
#           FILTER ( ?isNumeric = "false"^^xsd:boolean && ?maxCardinality != "infinity"^^xsd:string ) .
#           -----
			[   a sp:Filter ;
                sp:expression [
					a sp:and ;
                    sp:arg1  
						[   a sp:eq ;
                            sp:arg1 [ sp:varName "isNumeric"^^xsd:string ] ;
                            sp:arg2 "false"^^xsd:boolean ] ;
                    sp:arg2  
						[   a sp:ne ;
                            sp:arg1 [ sp:varName "maxCardinality"^^xsd:string ] ;
                            sp:arg2 "infinity"^^xsd:string ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The value string maximum occurrence constraint ( " ;
					sp:arg2 [ sp:varName "maxCardinality" ] ;
					sp:arg3 "^^" ;
					sp:arg4 [ sp:varName "datatype" ] ;
					sp:arg5 " ) is not a non-negative integer or 'infinity' as specified by the description template ( " ;
					sp:arg6 [ sp:varName "this" ] ;
					sp:arg7 " )" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Literal List Constraint [done]


# Summary: Literals that are allowed as values. 
# Allowed values: a list of literals, i.e. (string, language tag) or (string, syntax encoding scheme URI) pairs. 
# Default: no constraint 
# Conditions: if given, no other literal constraint may be given 


# -----
dsp2spin:NonLiteralValueConstraints_LiteralListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
					
#           ?object rdf:value ?literal .
#           -----
			[   sp:subject [ sp:varName "object" ] ;
			    sp:predicate rdf:value ;
				sp:object [ sp:varName "literal" ] ]					
				
#           BIND( ( IF( sp:datatype( ?literal^^xsd:string ) = rdf:langString, sp:lang( ?literal^^xsd:string ), sp:datatype( ?literal^^xsd:string ) ) ) AS ?datatypeOrLanguage^^xsd:string ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ 
							a sp:datatype;
							sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
						sp:arg2 rdf:langString ] ;
                    sp:arg2 [ 
						a sp:lang;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
                    sp:arg3 [ 
						a sp:datatype;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ] ;
                sp:variable [ sp:varName "datatypeOrLanguage"^^xsd:string ] ]
					
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]				
				
#			FILTER EXISTS { ?valueStringConstraint dsp:literal ?l }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "l" ] ] ) ] ]
				
#			FILTER NOT EXISTS { ?valueStringConstraint dsp:literal ?literal }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Value string ( " ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 "^^" ;
					sp:arg4 [ sp:varName "datatypeOrLanguage" ] ;
					sp:arg5 " ) not allowed for description template ( " ;
					sp:arg6 [ sp:varName "descriptionTemplate" ] ;
					sp:arg7 " )" ] ] ) ].
					
# As a literal list constraint is given, no literal language constraint can be given	
# -----
dsp2spin:NonLiteralValueConstraints_LiteralListConstraint_LiteralLanguageConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
					
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]					

#			FILTER EXISTS { 
#               ?object rdf:value ?literal .
#               ?valueStringConstraint dsp:literal ?literal . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "object" ] ;
							sp:predicate rdf:value ;
							sp:object [ sp:varName "literal" ] ]
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]
							
#			FILTER EXISTS { ?valueStringConstraint dsp:languageOccurrence ?languageOccurrence }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:languageOccurrence ;
                            sp:object [ sp:varName "languageOccurrence" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As a literal list constraint is given, no literal language constraint can be given as specified in description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# As a literal list constraint is given, no literal language list constraint can be given	
# -----
dsp2spin:NonLiteralValueConstraints_LiteralListConstraint_LiteralLanguageListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
					
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
							
#			FILTER EXISTS { 
#               ?object rdf:value ?literal .
#               ?valueStringConstraint dsp:literal ?literal . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "object" ] ;
							sp:predicate rdf:value ;
							sp:object [ sp:varName "literal" ] ]
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]
							
#			FILTER EXISTS { ?valueStringConstraint dsp:language ?language }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:language ;
                            sp:object [ sp:varName "language" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As a literal list constraint is given, no literal language list constraint can be given as specified in description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# As a literal list constraint is given, no syntax encoding scheme constraint can be given	
# -----
dsp2spin:NonLiteralValueConstraints_LiteralListConstraint_SyntaxEncodingSchemeConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
					
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
							
#			FILTER EXISTS { 
#               ?object rdf:value ?literal .
#               ?valueStringConstraint dsp:literal ?literal . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "object" ] ;
							sp:predicate rdf:value ;
							sp:object [ sp:varName "literal" ] ]
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]
							
#			FILTER EXISTS { ?valueStringConstraint dsp:syntaxEncodingSchemeOccurrence ?syntaxEncodingSchemeOccurrence }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
                            sp:object [ sp:varName "syntaxEncodingSchemeOccurrence" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As a literal list constraint is given, no syntax encoding scheme constraint can be given as specified in description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# As a literal list constraint is given, no syntax encoding scheme list constraint can be given	
# -----
dsp2spin:NonLiteralValueConstraints_LiteralListConstraint_SyntaxEncodingSchemeListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
					
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
							
#			FILTER EXISTS { 
#               ?object rdf:value ?literal .
#               ?valueStringConstraint dsp:literal ?literal . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "object" ] ;
							sp:predicate rdf:value ;
							sp:object [ sp:varName "literal" ] ]
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]
							
#			FILTER EXISTS { ?valueStringConstraint dsp:syntaxEncodingScheme ?syntaxEncodingScheme }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "syntaxEncodingScheme" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As a literal list constraint is given, no syntax encoding scheme list constraint can be given as specified in description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# -----

# ---------------
# Non-Literal Value Constraints - Literal Language Constraint [done]


# Summary: Whether languages are allowed for the literal 
# Allowed values: mandatory, optional, disallowed 
# Default: optional
# Conditions: if "mandatory", Syntax encoding schemes are automatically disallowed 


# mandatory
# -----
dsp2spin:NonLiteralValueConstraints_LiteralLanguageConstraint_Mandatory
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           description template:			
#           ----------

#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
				
#           ?valueStringConstraint dsp:languageOccurrence ?languageOccurrence .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:languageOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]
			
#           instance:			
#           ----------
				
#           ?subject rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?subject ?property ?this .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]			

#			?this rdf:value ?literal
#           -----
			[   sp:subject [ sp:varName "this" ] ;
				sp:predicate rdf:value ;
				sp:object [ sp:varName "literal" ] ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
					
#           BIND( ( IF( sp:datatype( ?literal^^xsd:string ) = rdf:langString, sp:lang( ?literal^^xsd:string ), sp:datatype( ?literal^^xsd:string ) ) ) AS ?datatypeOrLanguage^^xsd:string ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ 
							a sp:datatype;
							sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
						sp:arg2 rdf:langString ] ;
                    sp:arg2 [ 
						a sp:lang;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
                    sp:arg3 [ 
						a sp:datatype;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ] ;
                sp:variable [ sp:varName "datatypeOrLanguage"^^xsd:string ] ]
					
#           constraints:			
#           ----------
				
#			FILTER ( ?language = "" ) .
#           -----   
			[   a sp:Filter ;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "language" ] ;
					sp:arg2 "" ] ]	

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Language mandatory for the value string ( '" ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 "'^^" ;
					sp:arg4 [ sp:varName "datatypeOrLanguage" ] ;
					sp:arg5 " ) as specified in the description template ( " ;
					sp:arg6 [ sp:varName "descriptionTemplate" ] ;
					sp:arg7 " )" ] ] ) ].
					
# if "mandatory", syntax encoding schemes are automatically disallowed 
# -----
dsp2spin:NonLiteralValueConstraints_LiteralLanguageConstraint_Mandatory_SyntaxEncodingSchemes
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           description template:			
#           ----------

#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
				
#           ?valueStringConstraint dsp:languageOccurrence ?languageOccurrence .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:languageOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]
			
#           instance:			
#           ----------
				
#           ?subject rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?subject ?property ?this .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]			

#			?this rdf:value ?literal
#           -----
			[   sp:subject [ sp:varName "this" ] ;
				sp:predicate rdf:value ;
				sp:object [ sp:varName "literal" ] ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
					
#           BIND( ( IF( sp:datatype( ?literal^^xsd:string ) = rdf:langString, sp:lang( ?literal^^xsd:string ), sp:datatype( ?literal^^xsd:string ) ) ) AS ?datatypeOrLanguage^^xsd:string ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ 
							a sp:datatype;
							sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
						sp:arg2 rdf:langString ] ;
                    sp:arg2 [ 
						a sp:lang;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
                    sp:arg3 [ 
						a sp:datatype;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ] ;
                sp:variable [ sp:varName "datatypeOrLanguage"^^xsd:string ] ]
					
#           constraints:			
#           ----------
				
#           BIND ( ( datatype ( ?literal ) ) AS ?datatype ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "literal" ] ] ] 

#           FILTER ( ?datatype != rdf:langString ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "datatype" ] ;
					sp:arg2 rdf:langString ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "As the literal language constraint is mandatory, syntax encoding schemes are automatically disallowed for literal ( '" ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 "'^^" ;
					sp:arg4 [ sp:varName "datatypeOrLanguage" ] ;
					sp:arg5 " ) as specified in description template ( " ;
					sp:arg6 [ sp:varName "descriptionTemplate" ] ;
					sp:arg7 " )" ] ] ) ].
					
# disallowed				
# -----
dsp2spin:NonLiteralValueConstraints_LiteralLanguageConstraint_Disallowed
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           description template:			
#           ----------

#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
				
#           ?valueStringConstraint dsp:languageOccurrence ?languageOccurrence .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:languageOccurrence ;
				sp:object "disallowed"^^dsp:occurrence ]
			
#           instance:			
#           ----------
				
#           ?subject rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?subject ?property ?this .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]			

#			?this rdf:value ?literal
#           -----
			[   sp:subject [ sp:varName "this" ] ;
				sp:predicate rdf:value ;
				sp:object [ sp:varName "literal" ] ] 
					
#           BIND( ( IF( sp:datatype( ?literal^^xsd:string ) = rdf:langString, sp:lang( ?literal^^xsd:string ), sp:datatype( ?literal^^xsd:string ) ) ) AS ?datatypeOrLanguage^^xsd:string ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ 
							a sp:datatype;
							sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
						sp:arg2 rdf:langString ] ;
                    sp:arg2 [ 
						a sp:lang;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
                    sp:arg3 [ 
						a sp:datatype;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ] ;
                sp:variable [ sp:varName "datatypeOrLanguage"^^xsd:string ] ]
					
#           constraints:			
#           ----------

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
					
#			FILTER ( ?language != "" ) .
#           -----   
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "language" ] ;
					sp:arg2 "" ] ]	

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Languages not allowed for value string ( '" ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 "'@" ;
					sp:arg4 [ sp:varName "language" ] ;
					sp:arg5 " ) as specified in description template ( " ;
					sp:arg6 [ sp:varName "descriptionTemplate" ] ;
					sp:arg7 " )" ] ] ) ].
					
# -----

# --------------
# Literal Value Constraints - Literal Language List Constraint [done]


# Summary: languages allowed for the literal 
# Allowed values: a list consisting of language tags 
# Default: no constraint  


# -----
dsp2spin:NonLiteralValueConstraints_LiteralLanguageListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           description template:			
#           ----------

#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
			
#           instance:			
#           ----------
				
#           ?subject rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?subject ?property ?this .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]			

#			?this rdf:value ?literal
#           -----
			[   sp:subject [ sp:varName "this" ] ;
				sp:predicate rdf:value ;
				sp:object [ sp:varName "literal" ] ] 
				
#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
					
#           BIND( ( IF( sp:datatype( ?literal^^xsd:string ) = rdf:langString, sp:lang( ?literal^^xsd:string ), sp:datatype( ?literal^^xsd:string ) ) ) AS ?datatypeOrLanguage^^xsd:string ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ 
							a sp:datatype;
							sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
						sp:arg2 rdf:langString ] ;
                    sp:arg2 [ 
						a sp:lang;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
                    sp:arg3 [ 
						a sp:datatype;
						sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ] ;
                sp:variable [ sp:varName "datatypeOrLanguage"^^xsd:string ] ]
					
#           constraints:			
#           ----------				
	
#           FILTER EXISTS { ?valueStringConstraint dsp:language ?languageDef . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:language ;
                            sp:object [ sp:varName "languageDef" ] ] ) ] ]

#           FILTER NOT EXISTS { 
#               ?valueStringConstraint dsp:language ?languageDefinition . 
#               BIND( ( IF( ?language^^xsd:string = ?languageDefinition^^xsd:string, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?match ) .
#               FILTER ( ?match = "true"^^xsd:boolean ) . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:language ;
                            sp:object [ sp:varName "languageDefinition" ] ] 	
						[   a sp:Bind ;
							sp:expression [
								a sp:if ;
								sp:arg1 [ 
									a sp:eq ;
									sp:arg1 [ sp:varName "language"^^xsd:string ] ;
									sp:arg2 [ sp:varName "languageDefinition"^^xsd:string ] ] ;
								sp:arg2 "true"^^xsd:boolean ;
								sp:arg3 "false"^^xsd:boolean ] ;
							sp:variable [ sp:varName "match"^^xsd:boolean ] ] 
						[   a sp:Filter ;
							sp:expression [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "match"^^xsd:boolean ] ;
								sp:arg2 "true"^^xsd:boolean ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "The language ( " ;
					sp:arg2 [ sp:varName "language" ] ;
					sp:arg3 " ) is not allowed for the value string ( '" ;
					sp:arg4 [ sp:varName "literal" ] ;
					sp:arg5 "'^^" ;
					sp:arg6 [ sp:varName "datatypeOrLanguage" ] ;
					sp:arg7 " ) as specified in description template ( " ;
					sp:arg8 [ sp:varName "descriptionTemplate" ] ;
					sp:arg9 " )" ] ] ) ].
						
# -----

# ---------------
# Non-Literal Value Constraints - Syntax Encoding Scheme Constraint [done]


# Summary: Whether Syntax Encoding Schemes are allowed for the literal 
# Allowed values: mandatory, optional, disallowed 
# Default: optional --> no constraint needed 
# Conditions: if "mandatory", language tags are automatically disallowed. 

# limitations
# - If there is no datatype IRI and no language tag, the datatype is xsd:string
# - If there is a language tag, the datatype is rdf:langString


# mandatory
# - no dattype and language tag --> datatype = rdf:langString 
# - no datatype IRI and no language tag --> datatype = xsd:string
# --> no constraint needed
# -----
dsp2spin:NonLiteralValueConstraints_SyntaxEncodingSchemeConstraint_Mandatory
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
				
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object _:violationSource ] 
			[   sp:subject _:violationSource ;
				sp:predicate rdf:type ;
				sp:object rdfs:Resource ]
			[   sp:subject _:violationSource ; 
				sp:predicate rdfs:label ;
				sp:object "violationSource" ] 
				
#			[   sp:subject _:violation ;
#				sp:predicate spin:violationSource ;
#				sp:object [ sp:varName "violationSource" ] ] 
			) ;
		sp:where ( 
#		WHERE {	
#           description template:			
#           ----------

#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
				
#           ?valueStringConstraint dsp:syntaxEncodingSchemeOccurrence "mandatory"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]	
			
#           instance:			
#           ----------
				
#           ?subject rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?subject ?property ?this .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]			
					
#           constraints:			
#           ----------		

#           FILTER EXISTS { ?this rdf:value ?l . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:value ;
                            sp:object [ sp:varName "l" ] ] ) ] ]		
							
#           If there is a language tag, the datatype is rdf:langString:
#           -----
#           FILTER EXISTS { 
#               ?this rdf:value ?literal .
#               BIND( ( IF( sp:datatype( ?literal^^xsd:string ) = rdf:langString, "false"^^xsd:boolean, "true"^^xsd:boolean ) ) AS ?isSyntaxEncodingScheme^^xsd:boolean ) .
#               FILTER ( ?isSyntaxEncodingScheme = "false"^^xsd:boolean ) . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 	
					    [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:value ;
                            sp:object [ sp:varName "literal" ] ]
						[   a sp:Bind ;
							sp:expression [
								a sp:if ;
								sp:arg1 [ 
									a sp:eq ;
									sp:arg1 [ 
										a sp:datatype;
										sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
									sp:arg2 rdf:langString ] ;
								sp:arg2 "false"^^xsd:boolean ;
								sp:arg3 "true"^^xsd:boolean ] ;
							sp:variable [ sp:varName "isSyntaxEncodingScheme"^^xsd:boolean ] ] 
						[   a sp:Filter ;
							sp:expression [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isSyntaxEncodingScheme"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax Encoding Schemes are mandatory as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# disallowed
# -----
dsp2spin:NonLiteralValueConstraints_SyntaxEncodingSchemeConstraint_Disallowed
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
				
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object _:violationSource ] 
			[   sp:subject _:violationSource ;
				sp:predicate rdf:type ;
				sp:object rdfs:Resource ]
			[   sp:subject _:violationSource ; 
				sp:predicate rdfs:label ;
				sp:object "violationSource" ] 
				
#			[   sp:subject _:violation ;
#				sp:predicate spin:violationSource ;
#				sp:object [ sp:varName "violationSource" ] ] 
			) ;
		sp:where ( 
#		WHERE {	
#           description template:			
#           ----------

#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
				
#           ?valueStringConstraint dsp:syntaxEncodingSchemeOccurrence "disallowed"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
				sp:object "disallowed"^^dsp:occurrence ]	
			
#           instance:			
#           ----------
				
#           ?subject rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?subject ?property ?this .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]			
					
#           constraints:			
#           ----------		

#           FILTER EXISTS { ?this rdf:value ?l . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:value ;
                            sp:object [ sp:varName "l" ] ] ) ] ]		
							
#           language tag --> datatype = rdf:langString 
#           no datatype IRI and no language tag --> datatype = xsd:string
#           -----
#           FILTER EXISTS { 
#               ?this rdf:value ?literal .
#               BIND( ( IF( sp:datatype( ?literal^^xsd:string ) = rdf:langString || sp:datatype( ?literal ) = xsd:string, "false"^^xsd:boolean, "true"^^xsd:boolean ) ) AS ?isSyntaxEncodingScheme^^xsd:boolean ) .
#               FILTER ( ?isSyntaxEncodingScheme = "true"^^xsd:boolean ) . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 	
					    [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:value ;
                            sp:object [ sp:varName "literal" ] ]
						[   a sp:Bind ;
							sp:expression [
								a sp:if ;
								sp:arg1 [ 
									a sp:or ;
									sp:arg1 [
										a sp:eq ;
										sp:arg1 [ 
											a sp:datatype;
											sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
										sp:arg2 rdf:langString ] ;
									sp:arg2 [
										a sp:eq ;
										sp:arg1 [ 
											a sp:datatype;
											sp:arg1 [ sp:varName "literal"^^xsd:string ] ] ;
										sp:arg2 xsd:string ] ] ;
								sp:arg2 "false"^^xsd:boolean ;
								sp:arg3 "true"^^xsd:boolean ] ;
							sp:variable [ sp:varName "isSyntaxEncodingScheme"^^xsd:boolean ] ] 
						[   a sp:Filter ;
							sp:expression [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isSyntaxEncodingScheme"^^xsd:boolean ] ;
								sp:arg2 "true"^^xsd:boolean ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax Encoding Schemes are disallowed as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# if "mandatory", language tags are automatically disallowed
# -----
dsp2spin:NonLiteralValueConstraints_SyntaxEncodingSchemeConstraint_LanguageTags
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
				
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object _:violationSource ] 
			[   sp:subject _:violationSource ;
				sp:predicate rdf:type ;
				sp:object rdfs:Resource ]
			[   sp:subject _:violationSource ; 
				sp:predicate rdfs:label ;
				sp:object "violationSource" ] 
				
#			[   sp:subject _:violation ;
#				sp:predicate spin:violationSource ;
#				sp:object [ sp:varName "violationSource" ] ] 
			) ;
		sp:where ( 
#		WHERE {	
#           description template:			
#           ----------

#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]	
				
#           ?valueStringConstraint dsp:syntaxEncodingSchemeOccurrence "mandatory"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "valueStringConstraint" ] ;
			    sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]	
			
#           instance:			
#           ----------
				
#           ?subject rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?subject ?property ?this .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]			
					
#           constraints:			
#           ----------		

#           FILTER EXISTS { ?this rdf:value ?l . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:value ;
                            sp:object [ sp:varName "l" ] ] ) ] ]
				
#           FILTER EXISTS { 
#               ?this rdf:value ?literal .
#               BIND ( ( lang ( ?literal ) ) AS ?language ) .
#               BIND( ( IF( ?language^^xsd:string != ""^^xsd:string, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLanguage ) .
#               FILTER ( ?isLanguage = "true"^^xsd:boolean ) . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate rdf:value ;
							sp:object [ sp:varName "literal" ] ]
						[   a sp:Bind;
							sp:variable [ sp:varName "language" ];
							sp:expression [
								a sp:lang;
								sp:arg1 [ sp:varName "literal" ] ] ] 	
						[   a sp:Bind ;
							sp:expression [
								a sp:if ;
								sp:arg1 [ 
									a sp:ne ;
									sp:arg1 [ sp:varName "language"^^xsd:string ] ;
									sp:arg2 ""^^xsd:string ] ;
								sp:arg2 "true"^^xsd:boolean ;
								sp:arg3 "false"^^xsd:boolean ] ;
							sp:variable [ sp:varName "isLanguage"^^xsd:boolean ] ] 
						[   a sp:Filter ;
							sp:expression [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isLanguage"^^xsd:boolean ] ;
								sp:arg2 "true"^^xsd:boolean ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax Encoding Schemes are mandatory and language tags are automatically disallowed as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].
					
# -----

# ---------------
# Non-Literal Value Constraints - Syntax Encoding Scheme List Constraint


# Summary: Syntax encoding schemes allowed for the literal 
# Allowed values: a list consisting of syntax encoding scheme URIs 
# Default: no constraint 


# -----
dsp2spin:NonLiteralValueConstraints_SyntaxEncodingSchemeListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           description template:			
#           ----------

#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:nonLiteralConstraint ?nonLiteralConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:nonLiteralConstraint ;
				sp:object [ sp:varName "nonLiteralConstraint" ] ]
				
#           ?nonLiteralConstraint dsp:valueStringConstraint ?valueStringConstraint .
#           -----
			[   sp:subject [ sp:varName "nonLiteralConstraint" ] ;
			    sp:predicate dsp:valueStringConstraint ;
				sp:object [ sp:varName "valueStringConstraint" ] ]		
			
#           instance:			
#           ----------
				
#           ?subject rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?subject ?property ?this .
#           -----
			[   sp:subject [ sp:varName "subject" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]			
					
#           constraints:			
#           ----------	
				
#           FILTER EXISTS { ?valueStringConstraint dsp:syntaxEncosingScheme ?ses . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "ses" ] ] ) ] ]
							
#           FILTER NOT EXISTS { 
#               ?this rdf:value ?literal . 
#               BIND ( ( datatype ( ?literal ) ) AS ?datatype ) .
#               ?valueStringConstraint dsp:syntaxEncosingScheme ?datatype . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate rdf:value ;
							sp:object [ sp:varName "literal" ] ]
						[   a sp:Bind;
							sp:variable [ sp:varName "datatype" ];
							sp:expression [
								a sp:datatype;
								sp:arg1 [ sp:varName "literal" ] ] ] 
						[   sp:subject [ sp:varName "valueStringConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "syntaxEncodingScheme" ] ]
						[   a sp:Filter ;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "syntaxEncodingScheme" ] ;
								sp:arg2 [ sp:varName "datatype" ] ] ]
							) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Some syntax encoding schemes are not allowed for value strings as specified in the description template ( " ;
					sp:arg2 [ sp:varName "descriptionTemplate" ] ;
					sp:arg3 " )" ] ] ) ].

# -----