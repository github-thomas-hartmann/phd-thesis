<?xml version="1.0" encoding="UTF-8"?>
<!--
Changelog:
1. smatyas: Added targetNamespace="uri:iso.org:21090" xmlns="uri:iso.org:21090" to xs:schema definition 
2. smatyas: maxOccurs="0" causes the schema to be invalid w/ Xerces-J. Basically, we need a way to cause ST.NT.translations to not exist within a ST.NT element however, this doesn't seem feasible. To move forward setting to maxOccurs="1"
<xs:element name="translation" type="ST" minOccurs="0" maxOccurs="0" />
 -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://www.ascc.net/xml/schematron" xmlns="uri:iso.org:21090" targetNamespace="uri:iso.org:21090" elementFormDefault="qualified">
	<xs:complexType name="Narrative" mixed="true">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ref="content"/>
			<xs:element ref="linkHtml"/>
			<xs:element ref="sub"/>
			<xs:element ref="sup"/>
			<xs:element ref="br"/>
			<xs:element ref="footnote"/>
			<xs:element ref="footnoteRef"/>
			<xs:element ref="renderMultiMedia"/>
			<xs:element ref="paragraph"/>
			<xs:element ref="list"/>
			<xs:element ref="table"/>
		</xs:choice>
		<xs:attribute name="ID" type="xs:ID"/>
		<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
	</xs:complexType>
	<xs:element name="text" type="Narrative"/>
	<xs:element name="br">
		<xs:complexType/>
	</xs:element>
	<xs:element name="caption">
		<xs:complexType mixed="true">
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="linkHtml"/>
				<xs:element ref="sub"/>
				<xs:element ref="sup"/>
				<xs:element ref="footnote"/>
				<xs:element ref="footnoteRef"/>
			</xs:choice>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="col">
		<xs:complexType>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="span" type="xs:string" default="1"/>
			<xs:attribute name="width" type="xs:string"/>
			<xs:attribute name="align">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="left"/>
						<xs:enumeration value="center"/>
						<xs:enumeration value="right"/>
						<xs:enumeration value="justify"/>
						<xs:enumeration value="char"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="char" type="xs:string"/>
			<xs:attribute name="charoff" type="xs:string"/>
			<xs:attribute name="valign">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="top"/>
						<xs:enumeration value="middle"/>
						<xs:enumeration value="bottom"/>
						<xs:enumeration value="baseline"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="colgroup">
		<xs:complexType>
			<xs:sequence minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="col"/>
			</xs:sequence>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="span" type="xs:string" default="1"/>
			<xs:attribute name="width" type="xs:string"/>
			<xs:attribute name="align">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="left"/>
						<xs:enumeration value="center"/>
						<xs:enumeration value="right"/>
						<xs:enumeration value="justify"/>
						<xs:enumeration value="char"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="char" type="xs:string"/>
			<xs:attribute name="charoff" type="xs:string"/>
			<xs:attribute name="valign">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="top"/>
						<xs:enumeration value="middle"/>
						<xs:enumeration value="bottom"/>
						<xs:enumeration value="baseline"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="content">
		<xs:complexType mixed="true">
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="content"/>
				<xs:element ref="linkHtml"/>
				<xs:element ref="sub"/>
				<xs:element ref="sup"/>
				<xs:element ref="br"/>
				<xs:element ref="footnote"/>
				<xs:element ref="footnoteRef"/>
				<xs:element ref="renderMultiMedia"/>
			</xs:choice>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="revised">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="insert"/>
						<xs:enumeration value="delete"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="footnote">
		<xs:complexType mixed="true">
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="content"/>
				<xs:element ref="linkHtml"/>
				<xs:element ref="sub"/>
				<xs:element ref="sup"/>
				<xs:element ref="br"/>
				<xs:element ref="renderMultiMedia"/>
				<xs:element ref="paragraph"/>
				<xs:element ref="list"/>
				<xs:element ref="table"/>
			</xs:choice>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="footnoteRef">
		<xs:complexType>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="IDREF" type="xs:IDREF" use="required"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="item">
		<xs:complexType mixed="true">
			<xs:sequence>
				<xs:element ref="caption" minOccurs="0"/>
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ref="content"/>
					<xs:element ref="linkHtml"/>
					<xs:element ref="sub"/>
					<xs:element ref="sup"/>
					<xs:element ref="br"/>
					<xs:element ref="footnote"/>
					<xs:element ref="footnoteRef"/>
					<xs:element ref="renderMultiMedia"/>
					<xs:element ref="paragraph"/>
					<xs:element ref="list"/>
					<xs:element ref="table"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="linkHtml">
		<xs:complexType mixed="true">
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="footnote"/>
				<xs:element ref="footnoteRef"/>
			</xs:choice>
			<xs:attribute name="name" type="xs:string"/>
			<xs:attribute name="href" type="xs:string"/>
			<xs:attribute name="rel" type="xs:string"/>
			<xs:attribute name="rev" type="xs:string"/>
			<xs:attribute name="title" type="xs:string"/>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="list">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="caption" minOccurs="0"/>
				<xs:element ref="item" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="listType" default="unordered">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="ordered"/>
						<xs:enumeration value="unordered"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="paragraph">
		<xs:complexType mixed="true">
			<xs:sequence>
				<xs:element ref="caption" minOccurs="0"/>
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ref="content"/>
					<xs:element ref="linkHtml"/>
					<xs:element ref="sub"/>
					<xs:element ref="sup"/>
					<xs:element ref="br"/>
					<xs:element ref="footnote"/>
					<xs:element ref="footnoteRef"/>
					<xs:element ref="renderMultiMedia"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="renderMultiMedia">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="caption" minOccurs="0"/>
			</xs:sequence>
			<xs:attribute name="referencedObject" type="xs:IDREFS" use="required"/>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="sub" type="xs:string"/>
	<xs:element name="sup" type="xs:string"/>
	<xs:element name="table">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="caption" minOccurs="0"/>
				<xs:choice>
					<xs:element ref="col" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="colgroup" minOccurs="0" maxOccurs="unbounded"/>
				</xs:choice>
				<xs:element ref="thead" minOccurs="0"/>
				<xs:element ref="tfoot" minOccurs="0"/>
				<xs:element ref="tbody" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="summary" type="xs:string"/>
			<xs:attribute name="width" type="xs:string"/>
			<xs:attribute name="border" type="xs:string"/>
			<xs:attribute name="frame">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="void"/>
						<xs:enumeration value="above"/>
						<xs:enumeration value="below"/>
						<xs:enumeration value="hsides"/>
						<xs:enumeration value="lhs"/>
						<xs:enumeration value="rhs"/>
						<xs:enumeration value="vsides"/>
						<xs:enumeration value="box"/>
						<xs:enumeration value="border"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="rules">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="none"/>
						<xs:enumeration value="groups"/>
						<xs:enumeration value="rows"/>
						<xs:enumeration value="cols"/>
						<xs:enumeration value="all"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="cellspacing" type="xs:string"/>
			<xs:attribute name="cellpadding" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="tbody">
		<xs:complexType>
			<xs:sequence maxOccurs="unbounded">
				<xs:element ref="tr"/>
			</xs:sequence>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="align">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="left"/>
						<xs:enumeration value="center"/>
						<xs:enumeration value="right"/>
						<xs:enumeration value="justify"/>
						<xs:enumeration value="char"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="char" type="xs:string"/>
			<xs:attribute name="charoff" type="xs:string"/>
			<xs:attribute name="valign">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="top"/>
						<xs:enumeration value="middle"/>
						<xs:enumeration value="bottom"/>
						<xs:enumeration value="baseline"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="td">
		<xs:complexType mixed="true">
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="content"/>
				<xs:element ref="linkHtml"/>
				<xs:element ref="sub"/>
				<xs:element ref="sup"/>
				<xs:element ref="br"/>
				<xs:element ref="footnote"/>
				<xs:element ref="footnoteRef"/>
				<xs:element ref="renderMultiMedia"/>
				<xs:element ref="paragraph"/>
				<xs:element ref="list"/>
			</xs:choice>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="abbr" type="xs:string"/>
			<xs:attribute name="axis" type="xs:string"/>
			<xs:attribute name="headers" type="xs:IDREFS"/>
			<xs:attribute name="scope">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="row"/>
						<xs:enumeration value="col"/>
						<xs:enumeration value="rowgroup"/>
						<xs:enumeration value="colgroup"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="rowspan" type="xs:string" default="1"/>
			<xs:attribute name="colspan" type="xs:string" default="1"/>
			<xs:attribute name="align">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="left"/>
						<xs:enumeration value="center"/>
						<xs:enumeration value="right"/>
						<xs:enumeration value="justify"/>
						<xs:enumeration value="char"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="char" type="xs:string"/>
			<xs:attribute name="charoff" type="xs:string"/>
			<xs:attribute name="valign">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="top"/>
						<xs:enumeration value="middle"/>
						<xs:enumeration value="bottom"/>
						<xs:enumeration value="baseline"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="tfoot">
		<xs:complexType>
			<xs:sequence maxOccurs="unbounded">
				<xs:element ref="tr"/>
			</xs:sequence>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="align">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="left"/>
						<xs:enumeration value="center"/>
						<xs:enumeration value="right"/>
						<xs:enumeration value="justify"/>
						<xs:enumeration value="char"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="char" type="xs:string"/>
			<xs:attribute name="charoff" type="xs:string"/>
			<xs:attribute name="valign">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="top"/>
						<xs:enumeration value="middle"/>
						<xs:enumeration value="bottom"/>
						<xs:enumeration value="baseline"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="th">
		<xs:complexType mixed="true">
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="content"/>
				<xs:element ref="linkHtml"/>
				<xs:element ref="sub"/>
				<xs:element ref="sup"/>
				<xs:element ref="br"/>
				<xs:element ref="footnote"/>
				<xs:element ref="footnoteRef"/>
				<xs:element ref="renderMultiMedia"/>
			</xs:choice>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="abbr" type="xs:string"/>
			<xs:attribute name="axis" type="xs:string"/>
			<xs:attribute name="headers" type="xs:IDREFS"/>
			<xs:attribute name="scope">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="row"/>
						<xs:enumeration value="col"/>
						<xs:enumeration value="rowgroup"/>
						<xs:enumeration value="colgroup"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="rowspan" type="xs:string" default="1"/>
			<xs:attribute name="colspan" type="xs:string" default="1"/>
			<xs:attribute name="align">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="left"/>
						<xs:enumeration value="center"/>
						<xs:enumeration value="right"/>
						<xs:enumeration value="justify"/>
						<xs:enumeration value="char"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="char" type="xs:string"/>
			<xs:attribute name="charoff" type="xs:string"/>
			<xs:attribute name="valign">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="top"/>
						<xs:enumeration value="middle"/>
						<xs:enumeration value="bottom"/>
						<xs:enumeration value="baseline"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="thead">
		<xs:complexType>
			<xs:sequence maxOccurs="unbounded">
				<xs:element ref="tr"/>
			</xs:sequence>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="align">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="left"/>
						<xs:enumeration value="center"/>
						<xs:enumeration value="right"/>
						<xs:enumeration value="justify"/>
						<xs:enumeration value="char"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="char" type="xs:string"/>
			<xs:attribute name="charoff" type="xs:string"/>
			<xs:attribute name="valign">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="top"/>
						<xs:enumeration value="middle"/>
						<xs:enumeration value="bottom"/>
						<xs:enumeration value="baseline"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="tr">
		<xs:complexType>
			<xs:choice maxOccurs="unbounded">
				<xs:element ref="th"/>
				<xs:element ref="td"/>
			</xs:choice>
			<xs:attribute name="ID" type="xs:ID"/>
			<xs:attribute name="language" type="xs:NMTOKEN"/>
			<xs:attribute name="styleCode" type="xs:NMTOKENS"/>
			<xs:attribute name="align">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="left"/>
						<xs:enumeration value="center"/>
						<xs:enumeration value="right"/>
						<xs:enumeration value="justify"/>
						<xs:enumeration value="char"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="char" type="xs:string"/>
			<xs:attribute name="charoff" type="xs:string"/>
			<xs:attribute name="valign">
				<xs:simpleType>
					<xs:restriction base="xs:NMTOKEN">
						<xs:enumeration value="top"/>
						<xs:enumeration value="middle"/>
						<xs:enumeration value="bottom"/>
						<xs:enumeration value="baseline"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:simpleType name="NullFlavor">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NI"/>
			<xs:enumeration value="INV"/>
			<xs:enumeration value="OTH"/>
			<xs:enumeration value="NINF"/>
			<xs:enumeration value="PINF"/>
			<xs:enumeration value="UNC"/>
			<xs:enumeration value="DER"/>
			<xs:enumeration value="UNK"/>
			<xs:enumeration value="ASKU"/>
			<xs:enumeration value="NAV"/>
			<xs:enumeration value="QS"/>
			<xs:enumeration value="NASK"/>
			<xs:enumeration value="TRC"/>
			<xs:enumeration value="MSK"/>
			<xs:enumeration value="NA"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="UpdateMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="A"/>
			<xs:enumeration value="AU"/>
			<xs:enumeration value="U"/>
			<xs:enumeration value="R"/>
			<xs:enumeration value="I"/>
			<xs:enumeration value="D"/>
			<xs:enumeration value="REF"/>
			<xs:enumeration value="K"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="Compression">
		<xs:restriction base="xs:string">
			<xs:enumeration value="DF"/>
			<xs:enumeration value="GZ"/>
			<xs:enumeration value="ZL"/>
			<xs:enumeration value="Z"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IntegrityCheckAlgorithm">
		<xs:restriction base="xs:string">
			<xs:enumeration value="SHA1"/>
			<xs:enumeration value="SHA256"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TelecommunicationAddressUse">
		<xs:restriction base="xs:string">
			<xs:enumeration value="H"/>
			<xs:enumeration value="HP"/>
			<xs:enumeration value="HV"/>
			<xs:enumeration value="WP"/>
			<xs:enumeration value="DIR"/>
			<xs:enumeration value="PUB"/>
			<xs:enumeration value="BAD"/>
			<xs:enumeration value="TMP"/>
			<xs:enumeration value="AS"/>
			<xs:enumeration value="EC"/>
			<xs:enumeration value="MC"/>
			<xs:enumeration value="PG"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="set_TelecommunicationAddressUse">
		<xs:list itemType="TelecommunicationAddressUse"/>
	</xs:simpleType>
	<xs:simpleType name="IdentifierScope">
		<xs:restriction base="xs:string">
			<xs:enumeration value="BUSN"/>
			<xs:enumeration value="OBJ"/>
			<xs:enumeration value="VER"/>
			<xs:enumeration value="VW"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IdentifierReliability">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ISS"/>
			<xs:enumeration value="VRF"/>
			<xs:enumeration value="USE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AddressPartType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AL"/>
			<xs:enumeration value="ADL"/>
			<xs:enumeration value="UNID"/>
			<xs:enumeration value="UNIT"/>
			<xs:enumeration value="DAL"/>
			<xs:enumeration value="DINST"/>
			<xs:enumeration value="DINSTA"/>
			<xs:enumeration value="DINSTQ"/>
			<xs:enumeration value="DMOD"/>
			<xs:enumeration value="DMODID"/>
			<xs:enumeration value="SAL"/>
			<xs:enumeration value="BNR"/>
			<xs:enumeration value="BNN"/>
			<xs:enumeration value="BNS"/>
			<xs:enumeration value="STR"/>
			<xs:enumeration value="STB"/>
			<xs:enumeration value="STTYP"/>
			<xs:enumeration value="DIR"/>
			<xs:enumeration value="CAR"/>
			<xs:enumeration value="CEN"/>
			<xs:enumeration value="CNT"/>
			<xs:enumeration value="CPA"/>
			<xs:enumeration value="CTY"/>
			<xs:enumeration value="DEL"/>
			<xs:enumeration value="POB"/>
			<xs:enumeration value="PRE"/>
			<xs:enumeration value="STA"/>
			<xs:enumeration value="ZIP"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PostalAddressUse">
		<xs:restriction base="xs:string">
			<xs:enumeration value="H"/>
			<xs:enumeration value="HP"/>
			<xs:enumeration value="HV"/>
			<xs:enumeration value="WP"/>
			<xs:enumeration value="DIR"/>
			<xs:enumeration value="PUB"/>
			<xs:enumeration value="BAD"/>
			<xs:enumeration value="TMP"/>
			<xs:enumeration value="ABC"/>
			<xs:enumeration value="IDE"/>
			<xs:enumeration value="SYL"/>
			<xs:enumeration value="PHYS"/>
			<xs:enumeration value="PST"/>
			<xs:enumeration value="SNDX"/>
			<xs:enumeration value="PHON"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="set_PostalAddressUse">
		<xs:list itemType="PostalAddressUse"/>
	</xs:simpleType>
	<xs:simpleType name="EntityNamePartType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="FAM"/>
			<xs:enumeration value="GIV"/>
			<xs:enumeration value="PFX"/>
			<xs:enumeration value="SFX"/>
			<xs:enumeration value="DEL"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="EntityNamePartQualifier">
		<xs:restriction base="xs:string">
			<xs:enumeration value="LS"/>
			<xs:enumeration value="AC"/>
			<xs:enumeration value="NB"/>
			<xs:enumeration value="PR"/>
			<xs:enumeration value="VV"/>
			<xs:enumeration value="AD"/>
			<xs:enumeration value="BR"/>
			<xs:enumeration value="SP"/>
			<xs:enumeration value="CL"/>
			<xs:enumeration value="IN"/>
			<xs:enumeration value="TITLE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="set_EntityNamePartQualifier">
		<xs:list itemType="EntityNamePartQualifier"/>
	</xs:simpleType>
	<xs:simpleType name="EntityNameUse">
		<xs:restriction base="xs:string">
			<xs:enumeration value="C"/>
			<xs:enumeration value="I"/>
			<xs:enumeration value="L"/>
			<xs:enumeration value="P"/>
			<xs:enumeration value="A"/>
			<xs:enumeration value="R"/>
			<xs:enumeration value="PHON"/>
			<xs:enumeration value="SNDX"/>
			<xs:enumeration value="ABC"/>
			<xs:enumeration value="SYL"/>
			<xs:enumeration value="IDE"/>
			<xs:enumeration value="ASGN"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="set_EntityNameUse">
		<xs:list itemType="EntityNameUse"/>
	</xs:simpleType>
	<xs:simpleType name="CalendarCycle">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CY"/>
			<xs:enumeration value="MY"/>
			<xs:enumeration value="CM"/>
			<xs:enumeration value="CW"/>
			<xs:enumeration value="WY"/>
			<xs:enumeration value="DM"/>
			<xs:enumeration value="CD"/>
			<xs:enumeration value="DY"/>
			<xs:enumeration value="DW"/>
			<xs:enumeration value="HD"/>
			<xs:enumeration value="CH"/>
			<xs:enumeration value="NH"/>
			<xs:enumeration value="CN"/>
			<xs:enumeration value="SN"/>
			<xs:enumeration value="CS"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TimingEvent">
		<xs:restriction base="xs:string">
			<xs:enumeration value="C"/>
			<xs:enumeration value="CD"/>
			<xs:enumeration value="CM"/>
			<xs:enumeration value="CV"/>
			<xs:enumeration value="HS"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CodingRationale">
		<xs:restriction base="xs:string">
			<xs:enumeration value="O"/>
			<xs:enumeration value="P"/>
			<xs:enumeration value="R"/>
			<xs:enumeration value="S"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="set_CodingRationale">
		<xs:list itemType="CodingRationale"/>
	</xs:simpleType>
	<xs:simpleType name="UncertaintyType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="U"/>
			<xs:enumeration value="N"/>
			<xs:enumeration value="LN"/>
			<xs:enumeration value="G"/>
			<xs:enumeration value="E"/>
			<xs:enumeration value="X2"/>
			<xs:enumeration value="T"/>
			<xs:enumeration value="F"/>
			<xs:enumeration value="B"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="Uid">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:simpleType name="Uri">
		<xs:restriction base="xs:anyURI"/>
	</xs:simpleType>
	<xs:simpleType name="Code">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:complexType name="BL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value if not null">
					<sch:rule abstract="true" id="BL-0">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:attribute name="value" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ANY" abstract="true">
		<xs:complexContent>
			<xs:extension base="HXIT">
				<xs:attribute name="nullFlavor" type="NullFlavor" use="optional"/>
				<xs:attribute name="flavorId" type="xs:string" use="optional"/>
				<xs:attribute name="updateMode" type="UpdateMode" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HXIT" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="extension requires root">
					<sch:rule abstract="true" id="HXIT-0">
						<sch:assert test="not(@controlActExtension) or @controlActRoot"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:attribute name="validTimeLow" type="xs:string" use="optional"/>
		<xs:attribute name="validTimeHigh" type="xs:string" use="optional"/>
		<xs:attribute name="controlActRoot" type="Uid" use="optional"/>
		<xs:attribute name="controlActExtension" type="xs:string" use="optional"/>
	</xs:complexType>
	<xs:complexType name="BL.NonNull">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="BL.NonNull cannot be null">
					<sch:rule abstract="true" id="BL.NonNull-0">
						<sch:assert test="not(@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="BL">
				<xs:attribute name="nullFlavor" type="NullFlavor" use="prohibited"/>
				<xs:attribute name="value" type="xs:boolean" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="only one of value, data, xml">
					<sch:rule abstract="true" id="ED-0">
						<sch:assert test="count(*[self::value or self::xml or self::data])&#60;=1"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="integrityCheckAlgorithm required">
					<sch:rule abstract="true" id="ED-1">
						<sch:assert test="not(integrityCheck) or @integrityCheckAlgorithm"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="thumbnail has value">
					<sch:rule abstract="true" id="ED-2">
						<sch:assert test="not(thumbnail) or thumbnail[(not(@nullFlavor) and count(*[self::@value or self::xml or self::data])=1) or (@nullFlavor and count(*[self::@value or self::xml or self::data])=0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="thumbnails do not use reference">
					<sch:rule abstract="true" id="ED-3">
						<sch:assert test="not(thumbnail) or thumbnail[not(@nullFlavor and reference)]"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="thumbnails do not have thumbnails">
					<sch:rule abstract="true" id="ED-4">
						<sch:assert test="not(thumbnail) or thumbnail[not(thumbnail)]"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="content is required if not null">
					<sch:rule abstract="true" id="ED-5">
						<sch:assert test="@nullFlavor or @value or xml or data"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="compression only on binary">
					<sch:rule abstract="true" id="ED-6">
						<sch:assert test="(@compression and data) or not(@compression or data)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="ED-7">
						<sch:assert test="count(*[self::reference or self::thumbnail][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="mediaType cannot be null">
					<sch:rule abstract="true" id="ED-8">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @mediaType)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="value implies mediaType is text/plain">
					<sch:rule abstract="true" id="ED-9">
						<sch:assert test="not(@value) or (@value and (not(@mediaType) or @mediaType=&#39;text/plain&#39;))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no charset for value or xml">
					<sch:rule abstract="true" id="ED-10">
						<sch:assert test="not(@value or xml) or not(@charset)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no nested translations">
					<sch:rule abstract="true" id="ED-11">
						<sch:assert test="not(translation) or thumbnail[not(translation)]"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no value if null">
					<sch:rule abstract="true" id="ED-12">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no data if null">
					<sch:rule abstract="true" id="ED-13">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@data))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no xml if null">
					<sch:rule abstract="true" id="ED-14">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@xml))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no reference if null">
					<sch:rule abstract="true" id="ED-15">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reference))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no mediaType if null">
					<sch:rule abstract="true" id="ED-16">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@mediaType))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no charset if null">
					<sch:rule abstract="true" id="ED-17">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@charset))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no language if null">
					<sch:rule abstract="true" id="ED-18">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@language))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no compression if null">
					<sch:rule abstract="true" id="ED-19">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@compression))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no integrityCheck if null">
					<sch:rule abstract="true" id="ED-20">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheck))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no integrityCheckAlgorithm if null">
					<sch:rule abstract="true" id="ED-21">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheckAlgorithm))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no thumbnail if null">
					<sch:rule abstract="true" id="ED-22">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@thumbnail))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no translation if null">
					<sch:rule abstract="true" id="ED-23">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="xml" type="xs:anyType" minOccurs="0" maxOccurs="1"/>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="value" type="xs:string" use="optional"/>
				<xs:attribute name="mediaType" type="xs:string" use="optional" default="text/plain"/>
				<xs:attribute name="charset" type="Code" use="optional"/>
				<xs:attribute name="language" type="Code" use="optional"/>
				<xs:attribute name="compression" type="Compression" use="optional"/>
				<xs:attribute name="integrityCheckAlgorithm" type="IntegrityCheckAlgorithm" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TEL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no updateMode or History on TEL attributes">
					<sch:rule abstract="true" id="TEL-0">
						<sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no use if null">
					<sch:rule abstract="true" id="TEL-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@use))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no useablePeriod if null">
					<sch:rule abstract="true" id="TEL-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@useablePeriod))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="URL">
				<xs:sequence>
					<xs:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="use" type="set_TelecommunicationAddressUse" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="URL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value is required">
					<sch:rule abstract="true" id="URL-0">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no value if null">
					<sch:rule abstract="true" id="URL-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:attribute name="value" type="xs:anyURI" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_TS" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED.Text">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="text only">
					<sch:rule abstract="true" id="ED.Text-0">
						<sch:assert test="@mediaType = &#34;&#39;text/plain&#39;&#34;"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no xml">
					<sch:rule abstract="true" id="ED.Text-1">
						<sch:assert test="not(xml)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no data">
					<sch:rule abstract="true" id="ED.Text-2">
						<sch:assert test="not(data)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no integrityCheck">
					<sch:rule abstract="true" id="ED.Text-3">
						<sch:assert test="not(integrityCheck)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no thumbnail">
					<sch:rule abstract="true" id="ED.Text-4">
						<sch:assert test="not(thumbnail)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no compression">
					<sch:rule abstract="true" id="ED.Text-5">
						<sch:assert test="not(@compression)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="ED.Text-6">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="ED">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="0"/>
					<xs:element name="xml" type="xs:anyType" minOccurs="0" maxOccurs="0"/>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="0"/>
					<xs:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="0"/>
					<xs:element name="translation" type="ED" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="mediaType" type="xs:string" use="required" fixed="text/plain"/>
				<xs:attribute name="compression" type="Compression" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED.Image">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="fixed to image">
					<sch:rule abstract="true" id="ED.Image-0">
						<sch:assert test="starts-with(@mediaType, &#34;image/&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no text">
					<sch:rule abstract="true" id="ED.Image-1">
						<sch:assert test="not(@value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no xml">
					<sch:rule abstract="true" id="ED.Image-2">
						<sch:assert test="not(xml)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="ED">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="xml" type="xs:anyType" minOccurs="0" maxOccurs="1"/>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="mediaType" type="xs:string" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED.Doc">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="mediaType">
					<sch:rule abstract="true" id="ED.Doc-0">
						<sch:assert test="mediaType = &#34;text/plain&#34; or mediaType = &#34;text/html&#34; or mediaType = &#34;text/xml&#34; or mediaType = &#34;application/pdf&#34;"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="ED">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="xml" type="xs:anyType" minOccurs="0" maxOccurs="1"/>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="mediaType" type="xs:string" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED.Doc.Ref">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="reference required">
					<sch:rule abstract="true" id="ED.Doc.Ref-0">
						<sch:assert test="not(@nullFlavor) or (reference and not(reference/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="ED.Doc">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="0"/>
					<xs:element name="xml" type="xs:anyType" minOccurs="0" maxOccurs="0"/>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="value" type="xs:string" use="prohibited"/>
				<xs:attribute name="mediaType" type="xs:string" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED.Doc.Inline">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no reference">
					<sch:rule abstract="true" id="ED.Doc.Inline-0">
						<sch:assert test="not(reference)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="ED.Doc">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="xml" type="xs:anyType" minOccurs="0" maxOccurs="1"/>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="0"/>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="mediaType" type="xs:string" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED.Signature">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no reference">
					<sch:rule abstract="true" id="ED.Signature-0">
						<sch:assert test="not(reference)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no value">
					<sch:rule abstract="true" id="ED.Signature-1">
						<sch:assert test="not(@value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no data">
					<sch:rule abstract="true" id="ED.Signature-2">
						<sch:assert test="not(data)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no integrityCheck">
					<sch:rule abstract="true" id="ED.Signature-3">
						<sch:assert test="not(integrityCheck)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no thumbnail">
					<sch:rule abstract="true" id="ED.Signature-4">
						<sch:assert test="not(thumbnail)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no compression">
					<sch:rule abstract="true" id="ED.Signature-5">
						<sch:assert test="not(@compression)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no language">
					<sch:rule abstract="true" id="ED.Signature-6">
						<sch:assert test="not(@language)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="mediaType">
					<sch:rule abstract="true" id="ED.Signature-7">
						<sch:assert test="@mediaType = &#34;&#39;text/xml&#39;&#34;"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="ED.Signature-8">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="ED">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="0"/>
					<xs:element name="xml" type="xs:anyType" minOccurs="0" maxOccurs="1"/>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="0"/>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="0"/>
					<xs:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="0"/>
					<xs:element name="translation" type="ED" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="value" type="xs:string" use="prohibited"/>
				<xs:attribute name="mediaType" type="xs:string" use="required" fixed="text/xml"/>
				<xs:attribute name="language" type="Code" use="prohibited"/>
				<xs:attribute name="compression" type="Compression" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED.Narrative">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="mediatype">
					<sch:rule abstract="true" id="ED.Narrative-0">
						<sch:assert test="@mediaType = &#34;&#39;text/x-hl7-text+xml&#39;&#34;"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no value">
					<sch:rule abstract="true" id="ED.Narrative-1">
						<sch:assert test="not(@value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no data">
					<sch:rule abstract="true" id="ED.Narrative-2">
						<sch:assert test="not(data)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="ED.Narrative-3">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="ED">
				<xs:sequence>
					<xs:element name="data" type="xs:base64Binary" minOccurs="0" maxOccurs="0"/>
					<xs:element name="xml" type="Narrative" minOccurs="0" maxOccurs="1"/>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="integrityCheck" type="xs:base64Binary" minOccurs="0" maxOccurs="1"/>
					<xs:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="translation" type="ED" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="value" type="xs:string" use="prohibited"/>
				<xs:attribute name="mediaType" type="xs:string" use="required" fixed="text/x-hl7-text+xml"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ST">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no nested translations">
					<sch:rule abstract="true" id="ST-0">
						<sch:assert test="not(translation) or thumbnail[not(translation)]"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="null or content">
					<sch:rule abstract="true" id="ST-1">
						<sch:assert test="(@nullFlavor or (@value and string-length(@value)&#38;gt;0)) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="translation" type="ST" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="value" type="xs:string" use="optional"/>
				<xs:attribute name="language" type="Code" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ST.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="ST.NT-0">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="ST">
				<xs:sequence>
					<!-- Changelog 2. smatyas: maxOccurs="0" causes the schema to be invalid w/ Xerces-J; 
          basically, we need a way to cause ST.translation to not exist within a ST.NT value; 
          to move forward setting to maxOccurs="1"
          <xs:element name="translation" type="ST" minOccurs="0" maxOccurs="0" />
           -->
					<xs:element name="translation" type="ST" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SC">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no code if no value">
					<sch:rule abstract="true" id="SC-0">
						<sch:assert test="not(@nullFlavor) or (not(code) or (code/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SC attributes">
					<sch:rule abstract="true" id="SC-1">
						<sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ST">
				<xs:sequence>
					<xs:element name="code" type="CD" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or code and/or originalText">
					<sch:rule abstract="true" id="CD-0">
						<sch:assert test="@nullFlavor or @code or (originalText and not(originalText/@nullFlavor) or (originalTextReference and not(originalTextReference/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="qualifiers only if code">
					<sch:rule abstract="true" id="CD-1">
						<sch:assert test="not(qualifier) or @code"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="code requires codeSystem">
					<sch:rule abstract="true" id="CD-2">
						<sch:assert test="@codeSystem or not(@code)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="codeSystemName only if codeSystem">
					<sch:rule abstract="true" id="CD-3">
						<sch:assert test="@codeSystem or not(@codeSystemName)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="codeSystemVersion only if codeSystem">
					<sch:rule abstract="true" id="CD-4">
						<sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="displayName only if code">
					<sch:rule abstract="true" id="CD-5">
						<sch:assert test="@code or not(@displayName)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="valueSet only when code and codeSystem are blank">
					<sch:rule abstract="true" id="CD-6">
						<sch:assert test="not(@valueSet) or (not(@code) and not(@codeSystem))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No original text on translations">
					<sch:rule abstract="true" id="CD-7">
						<sch:assert test="not translation/originalText"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="Translations cannot have translations">
					<sch:rule abstract="true" id="CD-8">
						<sch:assert test="not translation/translation"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on CD elements">
					<sch:rule abstract="true" id="CD-9">
						<sch:assert test="count(*[self::displayName or self::originalText or self::originalTextReference or self::translation][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no code if null">
					<sch:rule abstract="true" id="CD-10">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@code))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no displayName if null">
					<sch:rule abstract="true" id="CD-11">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayName))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no qualifier if null">
					<sch:rule abstract="true" id="CD-12">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(qualifier))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no source if null">
					<sch:rule abstract="true" id="CD-13">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@source))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="displayName" type="ST" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="group" type="CDGroup" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="source" type="XReference" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="code" type="xs:string" use="optional"/>
				<xs:attribute name="codeSystem" type="Uid" use="optional"/>
				<xs:attribute name="codeSystemName" type="xs:string" use="optional"/>
				<xs:attribute name="codeSystemVersion" type="xs:string" use="optional"/>
				<xs:attribute name="valueSet" type="xs:string" use="optional"/>
				<xs:attribute name="valueSetVersion" type="xs:string" use="optional"/>
				<xs:attribute name="id" type="xs:ID" use="optional"/>
				<xs:attribute name="codingRationale" type="set_CodingRationale" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CR">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value is required">
					<sch:rule abstract="true" id="CR-0">
						<sch:assert test="value"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on CR attributes">
					<sch:rule abstract="true" id="CR-1">
						<sch:assert test="count(*[self::name or self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no original text on qualifiers">
					<sch:rule abstract="true" id="CR-2">
						<sch:assert test="not value/originalText"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="name" type="CD.CV" minOccurs="0" maxOccurs="1"/>
			<xs:element name="value" type="CD" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="inverted" type="xs:boolean" use="optional" default="false"/>
	</xs:complexType>
	<xs:complexType name="CD.CV">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="CD.CV-0">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="CD.CE">
				<xs:sequence>
					<xs:element name="displayName" type="ST" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="group" type="CDGroup" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="0"/>
					<xs:element name="source" type="XReference" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CD.CE">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no qualifiers">
					<sch:rule abstract="true" id="CD.CE-0">
						<sch:assert test="not(group) and not(qualifier)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="CD">
				<xs:sequence>
					<xs:element name="displayName" type="ST" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="group" type="CDGroup" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="source" type="XReference" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CDGroup">
		<xs:sequence>
			<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="XReference">
		<xs:attribute name="xref" type="xs:IDREF" use="required"/>
	</xs:complexType>
	<xs:complexType name="SC.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="SC.NT-0">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="SC">
				<xs:sequence>
					<xs:element name="translation" type="ST" minOccurs="0" maxOccurs="0"/>
					<xs:element name="code" type="CD" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TEL.Email">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="email only">
					<sch:rule abstract="true" id="TEL.Email-0">
						<sch:assert test="starts-with(@value, &#34;mailto&#34;)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TEL.Person">
				<xs:sequence>
					<xs:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TEL.Person">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Personal Address">
					<sch:rule abstract="true" id="TEL.Person-0">
						<sch:assert test="starts-with(@value, &#34;tel&#34;) or starts-with(@value, &#34;x-text-fax&#34;) or starts-with(@value, &#34;x-text-tel&#34;) or starts-with(@value, &#34;mailto&#34;)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TEL">
				<xs:sequence>
					<xs:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TEL.Phone">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Phone">
					<sch:rule abstract="true" id="TEL.Phone-0">
						<sch:assert test="starts-with(@value, &#34;tel&#34;) or starts-with(@value, &#34;x-text-fax&#34;) or starts-with(@value, &#34;x-text-tel&#34;)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TEL.Person">
				<xs:sequence>
					<xs:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TEL.Url">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no use">
					<sch:rule abstract="true" id="TEL.Url-0">
						<sch:assert test="not(use)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="schemes">
					<sch:rule abstract="true" id="TEL.Url-1">
						<sch:assert test="(starts-with(@value, &#34;file&#34;) or starts-with(@value, &#34;ftp&#34;) or starts-with(@value, &#34;http&#34;) or starts-with(@value, &#34;https&#34;) or starts-with(@value, &#34;nfs&#34;))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TEL">
				<xs:sequence>
					<xs:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="use" type="TelecommunicationAddressUse" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="II">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="root is required">
					<sch:rule abstract="true" id="II-0">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @root)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no root if null">
					<sch:rule abstract="true" id="II-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@root))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no extension if null">
					<sch:rule abstract="true" id="II-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@extension))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no identifierName if null">
					<sch:rule abstract="true" id="II-3">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@identifierName))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no displayable if null">
					<sch:rule abstract="true" id="II-4">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayable))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no reliability if null">
					<sch:rule abstract="true" id="II-5">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reliability))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:attribute name="root" type="Uid" use="optional"/>
				<xs:attribute name="extension" type="xs:string" use="optional"/>
				<xs:attribute name="identifierName" type="xs:string" use="optional"/>
				<xs:attribute name="displayable" type="xs:boolean" use="optional"/>
				<xs:attribute name="scope" type="IdentifierScope" use="optional"/>
				<xs:attribute name="reliability" type="IdentifierReliability" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CD.CE.None">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no qualifiers">
					<sch:rule abstract="true" id="CD.CE.None-0">
						<sch:assert test="count(*[self::translation][qualifier])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="CD.CE">
				<xs:sequence>
					<xs:element name="displayName" type="ST" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="group" type="CDGroup" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="translation" type="CD.CE" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="source" type="XReference" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have a code or a value">
					<sch:rule abstract="true" id="CO-0">
						<sch:assert test="@nullFlavor or (@value or (code and not(code/@nullFlavor)))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="CO-1">
						<sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no value if null">
					<sch:rule abstract="true" id="CO-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no code if null">
					<sch:rule abstract="true" id="CO-3">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@code))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="code" type="CD" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="value" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QTY" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="language required">
					<sch:rule abstract="true" id="QTY-0">
						<sch:assert test="not(expression) or (expression/@nullFlavor) or (@expressionLanguage)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="uncertainty has type">
					<sch:rule abstract="true" id="QTY-1">
						<sch:assert test="not(uncertainty) or (@uncertaintyType)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QTY-2">
						<sch:assert test="count(*[self::originalText or self::uncertainty or self::expression][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="expressionLanguage" type="Code" use="optional"/>
				<xs:attribute name="uncertaintyType" type="UncertaintyType" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="code is required">
					<sch:rule abstract="true" id="CS-0">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @code)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no code if null">
					<sch:rule abstract="true" id="CS-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@code))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:attribute name="code" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or parts">
					<sch:rule abstract="true" id="AD-0">
						<sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no useablePeriod if null">"
          <sch:rule abstract="true" id="AD-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@useablePeriod))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on AD attributes">
					<sch:rule abstract="true" id="AD-2">
						<sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="part" type="ADXP" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="use" type="set_PostalAddressUse" use="optional"/>
				<xs:attribute name="isNotOrdered" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ADXP">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value is required">
					<sch:rule abstract="true" id="ADXP-0">
						<sch:assert test="string-length(@value) &#62; 0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="code requires codeSystem">
					<sch:rule abstract="true" id="ADXP-1">
						<sch:assert test="@codeSystem or not(@code)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="codeSystemVersion only if codeSystem">
					<sch:rule abstract="true" id="ADXP-2">
						<sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:attribute name="value" type="xs:string" use="optional"/>
		<xs:attribute name="code" type="xs:string" use="optional"/>
		<xs:attribute name="codeSystem" type="xs:string" use="optional"/>
		<xs:attribute name="codeSystemVersion" type="xs:string" use="optional"/>
		<xs:attribute name="type" type="AddressPartType" use="optional"/>
	</xs:complexType>
	<xs:complexType name="EN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or parts">
					<sch:rule abstract="true" id="EN-0">
						<sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="part" type="ENXP" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="use" type="set_EntityNameUse" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ENXP">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value is required">
					<sch:rule abstract="true" id="ENXP-0">
						<sch:assert test="string-length(@value) &#62; 0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="code requires codeSystem">
					<sch:rule abstract="true" id="ENXP-1">
						<sch:assert test="@codeSystem or not(@code)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="codeSystemVersion only if codeSystem">
					<sch:rule abstract="true" id="ENXP-2">
						<sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:attribute name="value" type="xs:string" use="optional"/>
		<xs:attribute name="code" type="xs:string" use="optional"/>
		<xs:attribute name="codeSystem" type="xs:string" use="optional"/>
		<xs:attribute name="codeSystemVersion" type="xs:string" use="optional"/>
		<xs:attribute name="type" type="EntityNamePartType" use="optional"/>
		<xs:attribute name="qualifier" type="set_EntityNamePartQualifier" use="optional"/>
	</xs:complexType>
	<xs:complexType name="EN.TN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="only one part with no type">
					<sch:rule abstract="true" id="EN.TN-0">
						<sch:assert test="@nullFlavor or (count(part) = 1 and not part/@type)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="EN"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EN.PN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no parts are qualified by LS">
					<sch:rule abstract="true" id="EN.PN-0">
						<sch:assert test="count(part[contains(@qualifier, &#39;LS&#39;)])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="EN"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EN.ON">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no parts are person types">
					<sch:rule abstract="true" id="EN.ON-0">
						<sch:assert test="count(part[type = &#39;FAM&#39; or type = &#39;GIV&#39;])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="EN"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="TS-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:attribute name="value" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Date">
					<sch:rule abstract="true" id="TS.Date-0">
						<sch:assert test="not(contains(@value, &#34;+&#34;) or contains(@value, &#34;-&#34;)) and string-length(@value) &#60;= 8"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TS">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Full Date">
					<sch:rule abstract="true" id="TS.Date.Full-0">
						<sch:assert test="string-length(@value) = 8"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TS.Date">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="DateTime">
					<sch:rule abstract="true" id="TS.DateTime-0">
						<sch:assert test="(string-length(@value) &#60;= 14) or ((contains(@value, &#34;+&#34;) or contains(@value, &#34;-&#34;)) and string-length(@value) &#60;= 19)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TS">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Full DateTime">
					<sch:rule abstract="true" id="TS.DateTime.Full-0">
						<sch:assert test="string-length(@value) = 19 and (contains(@value, &#34;+&#34;) or contains(@value, &#34;-&#34;))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TS.DateTime">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="Birth">
					<sch:rule abstract="true" id="TS.Birth-0">
						<sch:assert test="((contains(@value, &#34;+&#34;) or contains(@value, &#34;-&#34;)) and string-length(@value) = 19) or (not(contains(@value, &#34;+&#34;) or contains(@value, &#34;-&#34;)) and (string-length(@value) = 8 or string-length(@value) = 4))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="TS">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="numerator and and denominator required">
					<sch:rule abstract="true" id="RTO-0">
						<sch:assert test="@nullFlavor or ((numerator and not(numerator/@nullFlavor)) and (numerator and not(numerator/@nullFlavor)))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on RTO Attributes">
					<sch:rule abstract="true" id="RTO-1">
						<sch:assert test="count(*[self::numerator or self::denominator][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="numerator" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="denominator" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="MO-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="null or currency">
					<sch:rule abstract="true" id="MO-1">
						<sch:assert test="(@nullFlavor or @currency) and not(@nullFlavor and @currency)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no precision if null">
					<sch:rule abstract="true" id="MO-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:attribute name="value" type="xs:double" use="optional"/>
				<xs:attribute name="precision" type="xs:int" use="optional"/>
				<xs:attribute name="currency" type="Code" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="PQ-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no precision if null">
					<sch:rule abstract="true" id="PQ-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no translation if null">
					<sch:rule abstract="true" id="PQ-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="translation" type="PQR" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="value" type="xs:double" use="optional"/>
				<xs:attribute name="precision" type="xs:int" use="optional" default="0"/>
				<xs:attribute name="unit" type="Code" use="optional"/>
				<xs:attribute name="codingRationale" type="set_CodingRationale" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PQR">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="PQR-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="PQR-1">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no qualifiers">
					<sch:rule abstract="true" id="PQR-2">
						<sch:assert test="not(group) and not(qualifier)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PQR">
					<sch:rule abstract="true" id="PQR-3">
						<sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not(@controlActRoot) and not(@controlActExtension) and not(@updateMode)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no precision if null">
					<sch:rule abstract="true" id="PQR-4">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CD">
				<xs:attribute name="value" type="xs:double" use="optional"/>
				<xs:attribute name="precision" type="xs:int" use="optional" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="PQ.Time-0">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="PQ">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="translation" type="PQR" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="REAL-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no precision if null">
					<sch:rule abstract="true" id="REAL-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:attribute name="value" type="xs:double" use="optional"/>
				<xs:attribute name="precision" type="xs:int" use="optional" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="INT-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:attribute name="value" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not negative">
					<sch:rule abstract="true" id="INT.NonNeg-0">
						<sch:assert test="@value &#62;= 0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="INT">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="positive">
					<sch:rule abstract="true" id="INT.Positive-0">
						<sch:assert test="@value &#62; 0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="INT.NonNeg">
				<xs:sequence>
					<xs:element name="expression" type="ED" minOccurs="0" maxOccurs="1"/>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_BL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_BL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_BL-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_BL">
				<xs:sequence>
					<xs:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_BL" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_BL.NonNull">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_BL.NonNull-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_BL.NonNull-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_BL.NonNull">
				<xs:sequence>
					<xs:element name="item" type="BL.NonNull" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_BL.NonNull" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ED">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ED-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ED-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED">
				<xs:sequence>
					<xs:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ED" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ED.Image">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ED.Image-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ED.Image-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Image">
				<xs:sequence>
					<xs:element name="item" type="ED.Image" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ED.Image" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ED.Text">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ED.Text-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ED.Text-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Text">
				<xs:sequence>
					<xs:element name="item" type="ED.Text" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ED.Text" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ED.Doc">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ED.Doc-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ED.Doc-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Doc">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ED.Doc" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ED.Doc.Ref">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ED.Doc.Ref-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ED.Doc.Ref-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Doc.Ref">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc.Ref" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ED.Doc.Ref" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ED.Doc.Inline">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ED.Doc.Inline-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ED.Doc.Inline-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Doc.Inline">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc.Inline" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ED.Doc.Inline" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ED.Signature">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ED.Signature-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ED.Signature-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Signature">
				<xs:sequence>
					<xs:element name="item" type="ED.Signature" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ED.Signature" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ED.Narrative">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ED.Narrative-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ED.Narrative-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Narrative">
				<xs:sequence>
					<xs:element name="item" type="ED.Narrative" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ED.Narrative" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ST">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ST-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ST-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ST">
				<xs:sequence>
					<xs:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ST" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_ST.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_ST.NT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_ST.NT-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ST.NT">
				<xs:sequence>
					<xs:element name="item" type="ST.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_ST.NT" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_SC">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_SC-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_SC-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_SC">
				<xs:sequence>
					<xs:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_SC" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_SC.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_SC.NT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_SC.NT-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_SC.NT">
				<xs:sequence>
					<xs:element name="item" type="SC.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_SC.NT" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TEL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TEL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TEL-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL">
				<xs:sequence>
					<xs:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TEL" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TEL.Email">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TEL.Email-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TEL.Email-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL.Email">
				<xs:sequence>
					<xs:element name="item" type="TEL.Email" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TEL.Email" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TEL.Person">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TEL.Person-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TEL.Person-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL.Person">
				<xs:sequence>
					<xs:element name="item" type="TEL.Person" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TEL.Person" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TEL.Phone">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TEL.Phone-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TEL.Phone-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL.Phone">
				<xs:sequence>
					<xs:element name="item" type="TEL.Phone" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TEL.Phone" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TEL.Url">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TEL.Url-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TEL.Url-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL.Url">
				<xs:sequence>
					<xs:element name="item" type="TEL.Url" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TEL.Url" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_II">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_II-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_II-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_II">
				<xs:sequence>
					<xs:element name="item" type="II" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_II" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_CD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_CD-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_CD-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CD">
				<xs:sequence>
					<xs:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_CD" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_CD.CE">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_CD.CE-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_CD.CE-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CD.CE">
				<xs:sequence>
					<xs:element name="item" type="CD.CE" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_CD.CE" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_CD.CE.None">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_CD.CE.None-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_CD.CE.None-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CD.CE.None">
				<xs:sequence>
					<xs:element name="item" type="CD.CE.None" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_CD.CE.None" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_CD.CV">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_CD.CV-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_CD.CV-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CD.CV">
				<xs:sequence>
					<xs:element name="item" type="CD.CV" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_CD.CV" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_CO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_CO-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CO">
				<xs:sequence>
					<xs:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_CO" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_CS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_CS-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_CS-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CS">
				<xs:sequence>
					<xs:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_CS" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_AD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_AD-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_AD-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_AD">
				<xs:sequence>
					<xs:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_AD" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_EN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_EN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_EN-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_EN">
				<xs:sequence>
					<xs:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_EN" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_EN.TN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_EN.TN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_EN.TN-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_EN.TN">
				<xs:sequence>
					<xs:element name="item" type="EN.TN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_EN.TN" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_EN.PN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_EN.PN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_EN.PN-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_EN.PN">
				<xs:sequence>
					<xs:element name="item" type="EN.PN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_EN.PN" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_EN.ON">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_EN.ON-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_EN.ON-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_EN.ON">
				<xs:sequence>
					<xs:element name="item" type="EN.ON" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_EN.ON" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TS-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TS-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS">
				<xs:sequence>
					<xs:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TS" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TS.Date-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TS.Date-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.Date">
				<xs:sequence>
					<xs:element name="item" type="TS.Date" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TS.Date" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TS.Date.Full-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TS.Date.Full-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.Date.Full">
				<xs:sequence>
					<xs:element name="item" type="TS.Date.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TS.Date.Full" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TS.DateTime-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TS.DateTime-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.DateTime">
				<xs:sequence>
					<xs:element name="item" type="TS.DateTime" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TS.DateTime" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TS.DateTime.Full-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TS.DateTime.Full-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="item" type="TS.DateTime.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TS.DateTime.Full" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_TS.Birth-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_TS.Birth-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.Birth">
				<xs:sequence>
					<xs:element name="item" type="TS.Birth" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_TS.Birth" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_RTO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_RTO-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_RTO">
				<xs:sequence>
					<xs:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_RTO" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_MO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_MO-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_MO">
				<xs:sequence>
					<xs:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_MO" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_PQ-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_PQ-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_PQ">
				<xs:sequence>
					<xs:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_PQ" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_PQ.Time-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_PQ.Time-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_PQ.Time">
				<xs:sequence>
					<xs:element name="item" type="PQ.Time" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_PQ.Time" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_REAL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_REAL-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_REAL">
				<xs:sequence>
					<xs:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_REAL" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_INT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_INT-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_INT">
				<xs:sequence>
					<xs:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_INT" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_INT.NonNeg-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_INT.NonNeg-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_INT.NonNeg">
				<xs:sequence>
					<xs:element name="item" type="INT.NonNeg" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_INT.NonNeg" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DSET_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="DSET_INT.Positive-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no null members">
					<sch:rule abstract="true" id="DSET_INT.Positive-1">
						<sch:assert test="@nullFlavor or not(item\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_INT.Positive">
				<xs:sequence>
					<xs:element name="item" type="INT.Positive" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="COLL_INT.Positive" abstract="true">
		<xs:complexContent>
			<xs:extension base="ANY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_BL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_BL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_BL">
				<xs:sequence>
					<xs:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_BL.NonNull">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_BL.NonNull-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_BL.NonNull">
				<xs:sequence>
					<xs:element name="item" type="BL.NonNull" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ED">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ED-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED">
				<xs:sequence>
					<xs:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ED.Image">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ED.Image-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Image">
				<xs:sequence>
					<xs:element name="item" type="ED.Image" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ED.Text">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ED.Text-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Text">
				<xs:sequence>
					<xs:element name="item" type="ED.Text" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ED.Doc">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ED.Doc-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Doc">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ED.Doc.Ref">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ED.Doc.Ref-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Doc.Ref">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc.Ref" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ED.Doc.Inline">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ED.Doc.Inline-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Doc.Inline">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc.Inline" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ED.Signature">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ED.Signature-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Signature">
				<xs:sequence>
					<xs:element name="item" type="ED.Signature" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ED.Narrative">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ED.Narrative-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ED.Narrative">
				<xs:sequence>
					<xs:element name="item" type="ED.Narrative" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ST">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ST-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ST">
				<xs:sequence>
					<xs:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_ST.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_ST.NT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_ST.NT">
				<xs:sequence>
					<xs:element name="item" type="ST.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_SC">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_SC-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_SC">
				<xs:sequence>
					<xs:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_SC.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_SC.NT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_SC.NT">
				<xs:sequence>
					<xs:element name="item" type="SC.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TEL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TEL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL">
				<xs:sequence>
					<xs:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TEL.Email">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TEL.Email-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL.Email">
				<xs:sequence>
					<xs:element name="item" type="TEL.Email" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TEL.Person">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TEL.Person-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL.Person">
				<xs:sequence>
					<xs:element name="item" type="TEL.Person" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TEL.Phone">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TEL.Phone-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL.Phone">
				<xs:sequence>
					<xs:element name="item" type="TEL.Phone" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TEL.Url">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TEL.Url-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TEL.Url">
				<xs:sequence>
					<xs:element name="item" type="TEL.Url" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_II">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_II-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_II">
				<xs:sequence>
					<xs:element name="item" type="II" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_CD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_CD-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CD">
				<xs:sequence>
					<xs:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_CD.CE">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_CD.CE-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CD.CE">
				<xs:sequence>
					<xs:element name="item" type="CD.CE" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_CD.CE.None">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_CD.CE.None-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CD.CE.None">
				<xs:sequence>
					<xs:element name="item" type="CD.CE.None" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_CD.CV">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_CD.CV-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CD.CV">
				<xs:sequence>
					<xs:element name="item" type="CD.CV" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_CO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CO">
				<xs:sequence>
					<xs:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_CS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_CS-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_CS">
				<xs:sequence>
					<xs:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_AD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_AD-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_AD">
				<xs:sequence>
					<xs:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_EN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_EN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_EN">
				<xs:sequence>
					<xs:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_EN.TN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_EN.TN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_EN.TN">
				<xs:sequence>
					<xs:element name="item" type="EN.TN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_EN.PN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_EN.PN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_EN.PN">
				<xs:sequence>
					<xs:element name="item" type="EN.PN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_EN.ON">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_EN.ON-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_EN.ON">
				<xs:sequence>
					<xs:element name="item" type="EN.ON" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TS-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS">
				<xs:sequence>
					<xs:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TS.Date-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.Date">
				<xs:sequence>
					<xs:element name="item" type="TS.Date" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TS.Date.Full-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.Date.Full">
				<xs:sequence>
					<xs:element name="item" type="TS.Date.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TS.DateTime-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.DateTime">
				<xs:sequence>
					<xs:element name="item" type="TS.DateTime" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TS.DateTime.Full-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="item" type="TS.DateTime.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_TS.Birth-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_TS.Birth">
				<xs:sequence>
					<xs:element name="item" type="TS.Birth" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_RTO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_RTO">
				<xs:sequence>
					<xs:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_MO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_MO">
				<xs:sequence>
					<xs:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_PQ-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_PQ">
				<xs:sequence>
					<xs:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_PQ.Time-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_PQ.Time">
				<xs:sequence>
					<xs:element name="item" type="PQ.Time" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_REAL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_REAL">
				<xs:sequence>
					<xs:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_INT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_INT">
				<xs:sequence>
					<xs:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_INT.NonNeg-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_INT.NonNeg">
				<xs:sequence>
					<xs:element name="item" type="INT.NonNeg" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BAG_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="null or not empty">
					<sch:rule abstract="true" id="BAG_INT.Positive-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="COLL_INT.Positive">
				<xs:sequence>
					<xs:element name="item" type="INT.Positive" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_BL">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_BL.NonNull">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="BL.NonNull" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ED">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ED.Image">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ED.Image" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ED.Text">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ED.Text" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ED.Doc">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ED.Doc.Ref">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc.Ref" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ED.Doc.Inline">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ED.Doc.Inline" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ED.Signature">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ED.Signature" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ED.Narrative">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ED.Narrative" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ST">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_ST.NT">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="ST.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_SC">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_SC.NT">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="SC.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TEL">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TEL.Email">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TEL.Email" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TEL.Person">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TEL.Person" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TEL.Phone">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TEL.Phone" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TEL.Url">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TEL.Url" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_II">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="II" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_CD">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_CD.CE">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="CD.CE" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_CD.CE.None">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="CD.CE.None" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_CD.CV">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="CD.CV" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_CO">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_CS">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_AD">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_EN">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_EN.TN">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="EN.TN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_EN.PN">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="EN.PN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_EN.ON">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="EN.ON" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TS">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TS.Date">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TS.Date" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TS.Date.Full">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TS.Date.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TS.DateTime">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TS.DateTime" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TS.DateTime.Full">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TS.DateTime.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_TS.Birth">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="TS.Birth" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_RTO">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_MO">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_PQ">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_PQ.Time">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="PQ.Time" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_REAL">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_INT">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_INT.NonNeg">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="INT.NonNeg" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LIST_INT.Positive">
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="INT.Positive" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_CO-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_CO-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_CO-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_CO">
				<xs:sequence>
					<xs:element name="low" type="CO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="CO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_CO" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_CO-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_TS-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS">
				<xs:sequence>
					<xs:element name="low" type="TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_TS.Date-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS.Date-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS.Date-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date">
				<xs:sequence>
					<xs:element name="low" type="TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_TS.Date" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS.Date-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_TS.Date.Full-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS.Date.Full-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS.Date.Full-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date.Full">
				<xs:sequence>
					<xs:element name="low" type="TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_TS.Date.Full" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS.Date.Full-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_TS.DateTime-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS.DateTime-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS.DateTime-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime">
				<xs:sequence>
					<xs:element name="low" type="TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_TS.DateTime" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS.DateTime-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_TS.DateTime.Full-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS.DateTime.Full-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS.DateTime.Full-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="low" type="TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_TS.DateTime.Full" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS.DateTime.Full-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_TS.Birth-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS.Birth-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS.Birth-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Birth">
				<xs:sequence>
					<xs:element name="low" type="TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_TS.Birth" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS.Birth-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_RTO-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_RTO-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_RTO-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_RTO">
				<xs:sequence>
					<xs:element name="low" type="RTO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="RTO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_RTO" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_RTO-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_MO-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_MO-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_MO-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_MO">
				<xs:sequence>
					<xs:element name="low" type="MO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="MO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_MO" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_MO-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_PQ-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_PQ-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_PQ-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ">
				<xs:sequence>
					<xs:element name="low" type="PQ" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="PQ" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_PQ" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_PQ-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_PQ.Time-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_PQ.Time-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_PQ.Time-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ.Time">
				<xs:sequence>
					<xs:element name="low" type="PQ.Time" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="PQ.Time" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_PQ.Time" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_PQ.Time-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_REAL-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_REAL-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_REAL-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_REAL">
				<xs:sequence>
					<xs:element name="low" type="REAL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="REAL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_REAL" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_REAL-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_INT-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_INT-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_INT-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT">
				<xs:sequence>
					<xs:element name="low" type="INT" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="INT" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_INT" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_INT-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_INT.NonNeg-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_INT.NonNeg-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_INT.NonNeg-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.NonNeg">
				<xs:sequence>
					<xs:element name="low" type="INT.NonNeg" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="INT.NonNeg" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_INT.NonNeg" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_INT.NonNeg-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="IVL_INT.Positive-0">
						<sch:assert test="(@nullFlavor and not(high or low or width)) or (not(@nullFlavor or width) and (high or low)) or (not(@nullFlavor or high or low) and width)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_INT.Positive-1">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_INT.Positive-2">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.Positive">
				<xs:sequence>
					<xs:element name="low" type="INT.Positive" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="INT.Positive" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="optional"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET_INT.Positive" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_INT.Positive-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_CO-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_CO-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_CO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="CO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="CO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_TS-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_TS-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_TS.Date-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_TS.Date-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Date">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.Date" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_TS.Date.Full-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_TS.Date.Full-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Date.Full">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.Date.Full" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_TS.DateTime-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_TS.DateTime-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.DateTime">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.DateTime" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_TS.DateTime.Full-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_TS.DateTime.Full-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.DateTime.Full" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_TS.Birth-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_TS.Birth-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Birth">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="TS.Birth" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_RTO-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_RTO-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_RTO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="RTO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="RTO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_MO-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_MO-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_MO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="MO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="MO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_PQ-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_PQ-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_PQ">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="PQ" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="PQ" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_PQ.Time-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_PQ.Time-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_PQ.Time">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="PQ.Time" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="PQ.Time" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_REAL-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_REAL-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_REAL">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="REAL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="REAL" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_INT-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_INT-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="INT" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_INT.NonNeg-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_INT.NonNeg-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT.NonNeg">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT.NonNeg" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="INT.NonNeg" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Low_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Low_INT.Positive-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Low_INT.Positive-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT.Positive">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT.Positive" minOccurs="0" maxOccurs="1"/>
					<xs:element name="high" type="INT.Positive" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_CO-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_CO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_CO-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_CO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="CO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="CO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_TS-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_TS-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_TS-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_TS.Date-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_TS.Date-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_TS.Date-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Date">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Date" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.Date" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_TS.Date.Full-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_TS.Date.Full-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_TS.Date.Full-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Date.Full">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Date.Full" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.Date.Full" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_TS.DateTime-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_TS.DateTime-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_TS.DateTime-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.DateTime">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.DateTime" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.DateTime" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_TS.DateTime.Full-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_TS.DateTime.Full-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_TS.DateTime.Full-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.DateTime.Full" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.DateTime.Full" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_TS.Birth-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_TS.Birth-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_TS.Birth-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Birth">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Birth" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.Birth" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_RTO-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_RTO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_RTO-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_RTO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="RTO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="RTO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_MO-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_MO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_MO-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_MO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="MO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="MO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_PQ-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_PQ-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_PQ-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_PQ">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="PQ" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="PQ" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_PQ.Time-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_PQ.Time-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_PQ.Time-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_PQ.Time">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="PQ.Time" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="PQ.Time" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_REAL-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_REAL-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_REAL-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_REAL">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="REAL" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="REAL" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_INT-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_INT-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_INT-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="INT" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_INT.NonNeg-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_INT.NonNeg-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_INT.NonNeg-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT.NonNeg">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT.NonNeg" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="INT.NonNeg" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.Width_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.Width_INT.Positive-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.Width_INT.Positive-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.Width_INT.Positive-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT.Positive">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT.Positive" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="INT.Positive" minOccurs="0" maxOccurs="0"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
				<xs:attribute name="highClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_CO-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_CO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_CO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="CO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="CO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_TS-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_TS-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_TS.Date-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_TS.Date-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Date">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Date" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_TS.Date.Full-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_TS.Date.Full-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Date.Full">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Date.Full" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_TS.DateTime-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_TS.DateTime-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.DateTime">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.DateTime" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_TS.DateTime.Full-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_TS.DateTime.Full-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.DateTime.Full" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_TS.Birth-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_TS.Birth-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_TS.Birth">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="TS.Birth" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_RTO-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_RTO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_RTO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="RTO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="RTO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_MO-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_MO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_MO">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="MO" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="MO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_PQ-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_PQ-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_PQ">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="PQ" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="PQ" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_PQ.Time-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_PQ.Time-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_PQ.Time">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="PQ.Time" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="PQ.Time" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_REAL-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_REAL-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_REAL">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="REAL" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="REAL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_INT-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_INT-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="INT" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_INT.NonNeg-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_INT.NonNeg-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT.NonNeg">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT.NonNeg" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="INT.NonNeg" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL.High_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.High_INT.Positive-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.High_INT.Positive-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="IVL_INT.Positive">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="low" type="INT.Positive" minOccurs="0" maxOccurs="0"/>
					<xs:element name="high" type="INT.Positive" minOccurs="0" maxOccurs="1"/>
					<xs:element name="width" type="QTY" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="lowClosed" type="xs:boolean" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_CO-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_CO-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="CO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_TS-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_TS-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_TS.Date-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_TS.Date-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_TS.Date.Full-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_TS.DateTime-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_TS.DateTime-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_TS.DateTime.Full-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_TS.Birth-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_TS.Birth-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_RTO-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_RTO-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="RTO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_MO-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_MO-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="MO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_PQ-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_PQ-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="PQ" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_PQ.Time-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_PQ.Time-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="PQ.Time" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_REAL-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_REAL-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="REAL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_INT-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_INT-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="INT" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_INT.NonNeg-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_INT.NonNeg-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="INT.NonNeg" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SLIST_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="SLIST_INT.Positive-0">
						<sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SLIST attributes">
					<sch:rule abstract="true" id="SLIST_INT.Positive-1">
						<sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="origin" type="INT.Positive" minOccurs="0" maxOccurs="1"/>
					<xs:element name="scale" type="QTY" minOccurs="0" maxOccurs="1"/>
					<xs:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_CO-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_CO-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_CO-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="CO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_TS-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_TS-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_TS-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_TS.Date-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_TS.Date-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_TS.Date-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_TS.Date.Full-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_TS.Date.Full-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_TS.DateTime-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_TS.DateTime-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_TS.DateTime-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_TS.DateTime.Full-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_TS.DateTime.Full-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_TS.Birth-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_TS.Birth-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_TS.Birth-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_RTO-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_RTO-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_RTO-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="RTO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_MO-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_MO-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_MO-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="MO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_PQ-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_PQ-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_PQ-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="PQ" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_PQ.Time-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_PQ.Time-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_PQ.Time-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="PQ.Time" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_REAL-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_REAL-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_REAL-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="REAL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_INT-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_INT-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_INT-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="INT" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_INT.NonNeg-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_INT.NonNeg-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_INT.NonNeg-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="INT.NonNeg" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GLIST_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="GLIST_INT.Positive-0">
						<sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="denominator must be positive">
					<sch:rule abstract="true" id="GLIST_INT.Positive-1">
						<sch:assert test="not(@denominator) or (@denominator &#62; 0)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on GLIST attributes">
					<sch:rule abstract="true" id="GLIST_INT.Positive-2">
						<sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="head" type="INT.Positive" minOccurs="0" maxOccurs="1"/>
					<xs:element name="increment" type="QTY" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="denominator" type="xs:int" use="optional"/>
				<xs:attribute name="period" type="xs:int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_CO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_CO">
				<xs:sequence>
					<xs:element name="first" type="QSET_CO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_CO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS.Date-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.Date" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date.Full">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.Date.Full" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS.DateTime-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.DateTime" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS.Birth-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Birth">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.Birth" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_RTO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_RTO">
				<xs:sequence>
					<xs:element name="first" type="QSET_RTO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_RTO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_MO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_MO">
				<xs:sequence>
					<xs:element name="first" type="QSET_MO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_MO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_PQ-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ">
				<xs:sequence>
					<xs:element name="first" type="QSET_PQ" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_PQ.Time-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ.Time">
				<xs:sequence>
					<xs:element name="first" type="QSET_PQ.Time" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_PQ.Time" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_REAL-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_REAL">
				<xs:sequence>
					<xs:element name="first" type="QSET_REAL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_REAL" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_INT-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT">
				<xs:sequence>
					<xs:element name="first" type="QSET_INT" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_INT" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_INT.NonNeg-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.NonNeg">
				<xs:sequence>
					<xs:element name="first" type="QSET_INT.NonNeg" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_INT.NonNeg" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSD_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_INT.Positive-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.Positive">
				<xs:sequence>
					<xs:element name="first" type="QSET_INT.Positive" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_INT.Positive" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_CO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_CO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_CO">
				<xs:sequence>
					<xs:element name="term" type="QSET_CO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS.Date-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS.Date-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.Date" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS.Date.Full-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date.Full">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.Date.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS.DateTime-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS.DateTime-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.DateTime" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS.DateTime.Full-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.DateTime.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS.Birth-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS.Birth-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Birth">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.Birth" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_RTO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_RTO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_RTO">
				<xs:sequence>
					<xs:element name="term" type="QSET_RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_MO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_MO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_MO">
				<xs:sequence>
					<xs:element name="term" type="QSET_MO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_PQ-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_PQ-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ">
				<xs:sequence>
					<xs:element name="term" type="QSET_PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_PQ.Time-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_PQ.Time-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ.Time">
				<xs:sequence>
					<xs:element name="term" type="QSET_PQ.Time" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_REAL-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_REAL-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_REAL">
				<xs:sequence>
					<xs:element name="term" type="QSET_REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_INT-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_INT-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT">
				<xs:sequence>
					<xs:element name="term" type="QSET_INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_INT.NonNeg-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_INT.NonNeg-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.NonNeg">
				<xs:sequence>
					<xs:element name="term" type="QSET_INT.NonNeg" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSI_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_INT.Positive-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_INT.Positive-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.Positive">
				<xs:sequence>
					<xs:element name="term" type="QSET_INT.Positive" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_CO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_CO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_CO">
				<xs:sequence>
					<xs:element name="term" type="QSET_CO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS.Date-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS.Date-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.Date" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS.Date.Full-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date.Full">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.Date.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS.DateTime-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS.DateTime-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.DateTime" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS.DateTime.Full-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.DateTime.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS.Birth-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS.Birth-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Birth">
				<xs:sequence>
					<xs:element name="term" type="QSET_TS.Birth" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_RTO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_RTO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_RTO">
				<xs:sequence>
					<xs:element name="term" type="QSET_RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_MO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_MO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_MO">
				<xs:sequence>
					<xs:element name="term" type="QSET_MO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_PQ-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_PQ-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ">
				<xs:sequence>
					<xs:element name="term" type="QSET_PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_PQ.Time-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_PQ.Time-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ.Time">
				<xs:sequence>
					<xs:element name="term" type="QSET_PQ.Time" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_REAL-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_REAL-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_REAL">
				<xs:sequence>
					<xs:element name="term" type="QSET_REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_INT-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_INT-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT">
				<xs:sequence>
					<xs:element name="term" type="QSET_INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_INT.NonNeg-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_INT.NonNeg-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.NonNeg">
				<xs:sequence>
					<xs:element name="term" type="QSET_INT.NonNeg" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSU_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_INT.Positive-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_INT.Positive-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.Positive">
				<xs:sequence>
					<xs:element name="term" type="QSET_INT.Positive" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_CO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_CO">
				<xs:sequence>
					<xs:element name="first" type="QSET_CO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_CO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS.Date-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.Date" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date.Full">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.Date.Full" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS.DateTime-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.DateTime" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS.Birth-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Birth">
				<xs:sequence>
					<xs:element name="first" type="QSET_TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_TS.Birth" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_RTO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_RTO">
				<xs:sequence>
					<xs:element name="first" type="QSET_RTO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_RTO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_MO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_MO">
				<xs:sequence>
					<xs:element name="first" type="QSET_MO" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_MO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_PQ-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ">
				<xs:sequence>
					<xs:element name="first" type="QSET_PQ" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_PQ.Time-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ.Time">
				<xs:sequence>
					<xs:element name="first" type="QSET_PQ.Time" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_PQ.Time" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_REAL-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_REAL">
				<xs:sequence>
					<xs:element name="first" type="QSET_REAL" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_REAL" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_INT-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT">
				<xs:sequence>
					<xs:element name="first" type="QSET_INT" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_INT" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_INT.NonNeg-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.NonNeg">
				<xs:sequence>
					<xs:element name="first" type="QSET_INT.NonNeg" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_INT.NonNeg" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSP_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_INT.Positive-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.Positive">
				<xs:sequence>
					<xs:element name="first" type="QSET_INT.Positive" minOccurs="0" maxOccurs="1"/>
					<xs:element name="second" type="QSET_INT.Positive" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_CO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_CO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_CO">
				<xs:sequence>
					<xs:element name="term" type="CO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS">
				<xs:sequence>
					<xs:element name="term" type="TS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.Date-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.Date-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date">
				<xs:sequence>
					<xs:element name="term" type="TS.Date" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.Date.Full-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date.Full">
				<xs:sequence>
					<xs:element name="term" type="TS.Date.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.DateTime-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.DateTime-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime">
				<xs:sequence>
					<xs:element name="term" type="TS.DateTime" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.DateTime.Full-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="term" type="TS.DateTime.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.Birth-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.Birth-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Birth">
				<xs:sequence>
					<xs:element name="term" type="TS.Birth" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_RTO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_RTO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_RTO">
				<xs:sequence>
					<xs:element name="term" type="RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_MO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_MO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_MO">
				<xs:sequence>
					<xs:element name="term" type="MO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_PQ-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_PQ-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ">
				<xs:sequence>
					<xs:element name="term" type="PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_PQ.Time-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_PQ.Time-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_PQ.Time">
				<xs:sequence>
					<xs:element name="term" type="PQ.Time" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_REAL-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_REAL-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_REAL">
				<xs:sequence>
					<xs:element name="term" type="REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_INT-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_INT-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT">
				<xs:sequence>
					<xs:element name="term" type="INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_INT.NonNeg-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_INT.NonNeg-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.NonNeg">
				<xs:sequence>
					<xs:element name="term" type="INT.NonNeg" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSS_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_INT.Positive-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_INT.Positive-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_INT.Positive">
				<xs:sequence>
					<xs:element name="term" type="INT.Positive" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PIVL_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="PIVL_TS-0">
						<sch:assert test="@nullFlavor or ((phase and not(period\@nullFlavor) and (phase and not(period\@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS">
				<xs:sequence>
					<xs:element name="phase" type="IVL_TS" minOccurs="0" maxOccurs="1"/>
					<xs:element name="period" type="PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="alignment" type="CalendarCycle" use="optional"/>
				<xs:attribute name="institutionSpecified" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PIVL_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="PIVL_TS.Date-0">
						<sch:assert test="@nullFlavor or ((phase and not(period\@nullFlavor) and (phase and not(period\@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS.Date-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date">
				<xs:sequence>
					<xs:element name="phase" type="IVL_TS.Date" minOccurs="0" maxOccurs="1"/>
					<xs:element name="period" type="PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="alignment" type="CalendarCycle" use="optional"/>
				<xs:attribute name="institutionSpecified" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PIVL_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="PIVL_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or ((phase and not(period\@nullFlavor) and (phase and not(period\@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS.Date.Full-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date.Full">
				<xs:sequence>
					<xs:element name="phase" type="IVL_TS.Date.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="period" type="PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="alignment" type="CalendarCycle" use="optional"/>
				<xs:attribute name="institutionSpecified" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PIVL_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="PIVL_TS.DateTime-0">
						<sch:assert test="@nullFlavor or ((phase and not(period\@nullFlavor) and (phase and not(period\@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS.DateTime-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime">
				<xs:sequence>
					<xs:element name="phase" type="IVL_TS.DateTime" minOccurs="0" maxOccurs="1"/>
					<xs:element name="period" type="PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="alignment" type="CalendarCycle" use="optional"/>
				<xs:attribute name="institutionSpecified" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PIVL_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="PIVL_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or ((phase and not(period\@nullFlavor) and (phase and not(period\@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS.DateTime.Full-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="phase" type="IVL_TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
					<xs:element name="period" type="PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="alignment" type="CalendarCycle" use="optional"/>
				<xs:attribute name="institutionSpecified" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PIVL_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="PIVL_TS.Birth-0">
						<sch:assert test="@nullFlavor or ((phase and not(period\@nullFlavor) and (phase and not(period\@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS.Birth-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Birth">
				<xs:sequence>
					<xs:element name="phase" type="IVL_TS.Birth" minOccurs="0" maxOccurs="1"/>
					<xs:element name="period" type="PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="alignment" type="CalendarCycle" use="optional"/>
				<xs:attribute name="institutionSpecified" type="xs:boolean" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EIVL_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS">
				<xs:sequence>
					<xs:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="event" type="TimingEvent" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EIVL_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS.Date-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS.Date-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date">
				<xs:sequence>
					<xs:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="event" type="TimingEvent" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EIVL_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS.Date.Full-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Date.Full">
				<xs:sequence>
					<xs:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="event" type="TimingEvent" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EIVL_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS.DateTime-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS.DateTime-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime">
				<xs:sequence>
					<xs:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="event" type="TimingEvent" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EIVL_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS.DateTime.Full-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.DateTime.Full">
				<xs:sequence>
					<xs:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="event" type="TimingEvent" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EIVL_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS.Birth-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS.Birth-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QSET_TS.Birth">
				<xs:sequence>
					<xs:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="event" type="TimingEvent" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_BL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_BL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_BL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_BL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_BL-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_BL-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_BL-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_BL-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="BL" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_BL.NonNull">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_BL.NonNull-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_BL.NonNull" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_BL.NonNull">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_BL.NonNull-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_BL.NonNull-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_BL.NonNull-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_BL.NonNull-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="BL.NonNull" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ED">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ED-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ED" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ED">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ED-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ED-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ED-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ED-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ED" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ED.Image">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ED.Image-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ED.Image" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ED.Image">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ED.Image-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ED.Image-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ED.Image-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ED.Image-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ED.Image" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ED.Text">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ED.Text-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ED.Text" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ED.Text">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ED.Text-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ED.Text-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ED.Text-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ED.Text-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ED.Text" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ED.Doc">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ED.Doc-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ED.Doc" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ED.Doc">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ED.Doc-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ED.Doc-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ED.Doc-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ED.Doc-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ED.Doc" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ED.Doc.Ref">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ED.Doc.Ref-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ED.Doc.Ref" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ED.Doc.Ref">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ED.Doc.Ref-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ED.Doc.Ref-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ED.Doc.Ref-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ED.Doc.Ref-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ED.Doc.Ref" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ED.Doc.Inline">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ED.Doc.Inline-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ED.Doc.Inline" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ED.Doc.Inline">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ED.Doc.Inline-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ED.Doc.Inline-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ED.Doc.Inline-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ED.Doc.Inline-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ED.Doc.Inline" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ED.Signature">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ED.Signature-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ED.Signature" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ED.Signature">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ED.Signature-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ED.Signature-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ED.Signature-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ED.Signature-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ED.Signature" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ED.Narrative">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ED.Narrative-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ED.Narrative" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ED.Narrative">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ED.Narrative-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ED.Narrative-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ED.Narrative-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ED.Narrative-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ED.Narrative" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ST">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ST-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ST" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ST">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ST-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ST-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ST-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ST-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ST" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_ST.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_ST.NT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_ST.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_ST.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_ST.NT-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_ST.NT-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_ST.NT-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_ST.NT-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="ST.NT" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_SC">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_SC-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_SC" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_SC">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_SC-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_SC-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_SC-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_SC-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="SC" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_SC.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_SC.NT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_SC.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_SC.NT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_SC.NT-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_SC.NT-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_SC.NT-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_SC.NT-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="SC.NT" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TEL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TEL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TEL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TEL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TEL-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TEL-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TEL-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TEL-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TEL" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TEL.Email">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TEL.Email-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TEL.Email" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TEL.Email">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TEL.Email-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TEL.Email-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TEL.Email-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TEL.Email-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TEL.Email" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TEL.Person">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TEL.Person-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TEL.Person" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TEL.Person">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TEL.Person-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TEL.Person-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TEL.Person-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TEL.Person-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TEL.Person" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TEL.Phone">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TEL.Phone-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TEL.Phone" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TEL.Phone">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TEL.Phone-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TEL.Phone-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TEL.Phone-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TEL.Phone-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TEL.Phone" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TEL.Url">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TEL.Url-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TEL.Url" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TEL.Url">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TEL.Url-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TEL.Url-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TEL.Url-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TEL.Url-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TEL.Url" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_II">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_II-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_II" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_II">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_II-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_II-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_II-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_II-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="II" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_CD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_CD-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_CD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_CD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_CD-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_CD-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_CD-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_CD-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="CD" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_CD.CE">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_CD.CE-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_CD.CE" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_CD.CE">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_CD.CE-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_CD.CE-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_CD.CE-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_CD.CE-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="CD.CE" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_CD.CE.None">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_CD.CE.None-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_CD.CE.None" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_CD.CE.None">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_CD.CE.None-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_CD.CE.None-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_CD.CE.None-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_CD.CE.None-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="CD.CE.None" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_CD.CV">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_CD.CV-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_CD.CV" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_CD.CV">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_CD.CV-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_CD.CV-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_CD.CV-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_CD.CV-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="CD.CV" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_CO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_CO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_CO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_CO-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_CO-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_CO-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_CO-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="CO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_CS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_CS-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_CS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_CS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_CS-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_CS-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_CS-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_CS-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="CS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_AD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_AD-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_AD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_AD">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_AD-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_AD-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_AD-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_AD-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="AD" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_EN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_EN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_EN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_EN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_EN-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_EN-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_EN-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_EN-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="EN" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_EN.TN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_EN.TN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_EN.TN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_EN.TN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_EN.TN-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_EN.TN-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_EN.TN-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_EN.TN-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="EN.TN" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_EN.PN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_EN.PN-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_EN.PN" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_EN.PN">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_EN.PN-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_EN.PN-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_EN.PN-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_EN.PN-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="EN.PN" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_EN.ON">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_EN.ON-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_EN.ON" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_EN.ON">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_EN.ON-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_EN.ON-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_EN.ON-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_EN.ON-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="EN.ON" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TS-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TS">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TS-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TS-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TS-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TS-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TS" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TS.Date-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TS.Date" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TS.Date">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TS.Date-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TS.Date-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TS.Date-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TS.Date-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TS.Date" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TS.Date.Full-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TS.Date.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TS.Date.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TS.Date.Full-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TS.Date.Full-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TS.Date.Full-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TS.Date.Full-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TS.Date.Full" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TS.DateTime-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TS.DateTime" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TS.DateTime">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TS.DateTime-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TS.DateTime-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TS.DateTime-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TS.DateTime-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TS.DateTime" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TS.DateTime.Full-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TS.DateTime.Full" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TS.DateTime.Full">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TS.DateTime.Full-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TS.DateTime.Full-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TS.DateTime.Full-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TS.DateTime.Full-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TS.DateTime.Full" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_TS.Birth-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_TS.Birth" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_TS.Birth">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_TS.Birth-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_TS.Birth-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_TS.Birth-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_TS.Birth-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="TS.Birth" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_RTO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_RTO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_RTO-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_RTO-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_RTO-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_RTO-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="RTO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_MO-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_MO" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_MO">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_MO-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_MO-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_MO-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_MO-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="MO" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_PQ-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_PQ">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_PQ-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_PQ-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_PQ-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_PQ-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="PQ" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_PQ.Time-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_PQ.Time" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_PQ.Time">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_PQ.Time-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_PQ.Time-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_PQ.Time-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_PQ.Time-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="PQ.Time" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_REAL-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_REAL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_REAL-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_REAL-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_REAL-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_REAL-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="REAL" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_INT-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_INT" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_INT">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_INT-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_INT-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_INT-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_INT-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="INT" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_INT.NonNeg-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_INT.NonNeg" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_INT.NonNeg">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_INT.NonNeg-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_INT.NonNeg-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_INT.NonNeg-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_INT.NonNeg-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="INT.NonNeg" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NPPD_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="must have at least one item">
					<sch:rule abstract="true" id="NPPD_INT.Positive-0">
						<sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="item" type="UVP_INT.Positive" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UVP_INT.Positive">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="value not null">
					<sch:rule abstract="true" id="UVP_INT.Positive-0">
						<sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="must have probability">
					<sch:rule abstract="true" id="UVP_INT.Positive-1">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @probability)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="probability must be valid">
					<sch:rule abstract="true" id="UVP_INT.Positive-2">
						<sch:assert test="not(@probability) or (@probability &#62;= 0 and @probability &#60;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="UVP_INT.Positive-3">
						<sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ANY">
				<xs:sequence>
					<xs:element name="value" type="INT.Positive" minOccurs="0" maxOccurs="1"/>
				</xs:sequence>
				<xs:attribute name="probability" type="xs:double" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QSET.BoundedPIVL">
		<xs:annotation>
			<xs:appinfo>
				<sch:pattern name="QSET.BoundedPIVL 2">
					<sch:rule abstract="true" id="QSET.BoundedPIVL-0">
						<sch:assert test="count(*)=2"/>
					</sch:rule>
				</sch:pattern>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="QSI_TS">
				<xs:sequence>
					<xs:element name="originalText" type="ED.Text" minOccurs="0" maxOccurs="1"/>
					<xs:element name="term" type="QSET_TS" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_BL">
		<xs:complexContent>
			<xs:extension base="LIST_BL"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_BL.NonNull">
		<xs:complexContent>
			<xs:extension base="LIST_BL.NonNull"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ED">
		<xs:complexContent>
			<xs:extension base="LIST_ED"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ED.Image">
		<xs:complexContent>
			<xs:extension base="LIST_ED.Image"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ED.Text">
		<xs:complexContent>
			<xs:extension base="LIST_ED.Text"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ED.Doc">
		<xs:complexContent>
			<xs:extension base="LIST_ED.Doc"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ED.Doc.Ref">
		<xs:complexContent>
			<xs:extension base="LIST_ED.Doc.Ref"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ED.Doc.Inline">
		<xs:complexContent>
			<xs:extension base="LIST_ED.Doc.Inline"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ED.Signature">
		<xs:complexContent>
			<xs:extension base="LIST_ED.Signature"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ED.Narrative">
		<xs:complexContent>
			<xs:extension base="LIST_ED.Narrative"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ST">
		<xs:complexContent>
			<xs:extension base="LIST_ST"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_ST.NT">
		<xs:complexContent>
			<xs:extension base="LIST_ST.NT"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_SC">
		<xs:complexContent>
			<xs:extension base="LIST_SC"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_SC.NT">
		<xs:complexContent>
			<xs:extension base="LIST_SC.NT"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TEL">
		<xs:complexContent>
			<xs:extension base="LIST_TEL"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TEL.Email">
		<xs:complexContent>
			<xs:extension base="LIST_TEL.Email"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TEL.Person">
		<xs:complexContent>
			<xs:extension base="LIST_TEL.Person"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TEL.Phone">
		<xs:complexContent>
			<xs:extension base="LIST_TEL.Phone"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TEL.Url">
		<xs:complexContent>
			<xs:extension base="LIST_TEL.Url"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_II">
		<xs:complexContent>
			<xs:extension base="LIST_II"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_CD">
		<xs:complexContent>
			<xs:extension base="LIST_CD"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_CD.CE">
		<xs:complexContent>
			<xs:extension base="LIST_CD.CE"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_CD.CE.None">
		<xs:complexContent>
			<xs:extension base="LIST_CD.CE.None"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_CD.CV">
		<xs:complexContent>
			<xs:extension base="LIST_CD.CV"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_CO">
		<xs:complexContent>
			<xs:extension base="LIST_CO"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_CS">
		<xs:complexContent>
			<xs:extension base="LIST_CS"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_AD">
		<xs:complexContent>
			<xs:extension base="LIST_AD"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_EN">
		<xs:complexContent>
			<xs:extension base="LIST_EN"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_EN.TN">
		<xs:complexContent>
			<xs:extension base="LIST_EN.TN"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_EN.PN">
		<xs:complexContent>
			<xs:extension base="LIST_EN.PN"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_EN.ON">
		<xs:complexContent>
			<xs:extension base="LIST_EN.ON"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TS">
		<xs:complexContent>
			<xs:extension base="LIST_TS"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TS.Date">
		<xs:complexContent>
			<xs:extension base="LIST_TS.Date"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TS.Date.Full">
		<xs:complexContent>
			<xs:extension base="LIST_TS.Date.Full"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TS.DateTime">
		<xs:complexContent>
			<xs:extension base="LIST_TS.DateTime"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TS.DateTime.Full">
		<xs:complexContent>
			<xs:extension base="LIST_TS.DateTime.Full"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_TS.Birth">
		<xs:complexContent>
			<xs:extension base="LIST_TS.Birth"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_RTO">
		<xs:complexContent>
			<xs:extension base="LIST_RTO"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_MO">
		<xs:complexContent>
			<xs:extension base="LIST_MO"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_PQ">
		<xs:complexContent>
			<xs:extension base="LIST_PQ"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_PQ.Time">
		<xs:complexContent>
			<xs:extension base="LIST_PQ.Time"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_REAL">
		<xs:complexContent>
			<xs:extension base="LIST_REAL"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_INT">
		<xs:complexContent>
			<xs:extension base="LIST_INT"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_INT.NonNeg">
		<xs:complexContent>
			<xs:extension base="LIST_INT.NonNeg"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HIST_INT.Positive">
		<xs:complexContent>
			<xs:extension base="LIST_INT.Positive"/>
		</xs:complexContent>
	</xs:complexType>
</xs:schema>
